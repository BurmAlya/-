1. Блочная (корзинная) сортировка

Определение 

Определение алгоритма
Блочная (корзинная) сортировка (Bucket Sort) — это алгоритм сортировки, который:

распределяет элементы входного массива по фиксированному числу «корзин» (блоков) на основе их значений;

сортирует каждую корзину отдельно (часто с помощью сортировки вставками);

объединяет отсортированные корзины в единый упорядоченный массив.

Оптимально работает при равномерном распределении данных по диапазону значений.

Код

def bucket_sort(arr, num_buckets=10):
    """
    Блочная (корзинная) сортировка.
    
    Параметры:
        arr (list): список чисел для сортировки (float или int).
        num_buckets (int): количество корзин (по умолчанию 10).
    
    Возвращает:
        list: отсортированный список.
    """
    if len(arr) == 0:
        return arr

    # Находим минимум и максимум для равномерного распределения по корзинам
    min_val = min(arr)
    max_val = max(arr)

    # Если все элементы одинаковы, возвращаем исходный массив
    if min_val == max_val:
        return arr

    # Создаём корзины (пустые списки)
    buckets = [[] for _ in range(num_buckets)]

    # Распределяем элементы по корзинам
    for num in arr:
        # Вычисляем индекс корзины
        # Нормализуем значение к диапазону [0, 1), затем умножаем на num_buckets
        index = int((num - min_val) / (max_val - min_val) * (num_buckets - 1))
        buckets[index].append(num)

    # Сортируем каждую корзину (алгоритмом вставки)
    for bucket in buckets:
        insertion_sort(bucket)

    # Объединяем корзины в один отсортированный массив
    sorted_arr = []
    for bucket in buckets:
        sorted_arr.extend(bucket)

    return sorted_arr



def insertion_sort(arr):
    """
    Сортировка вставками для отдельной корзины.
    
    Параметры:
        arr (list): список для сортировки.
    """
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key



# Пример использования
if __name__ == "__main__":
    # Тестовый массив
    data = [0.89, 0.56, 0.65, 0.12, 0.34, 0.98, 0.23, 0.76, 0.45, 0.01]
    print("Исходный массив:", data)

    sorted_data = bucket_sort(data, num_buckets=5)
    print("Отсортированный массив:", sorted_data)

Результат работы алгоритма
               
Исходный массив: [0.89, 0.56, 0.65, 0.12, 0.34, 0.98, 0.23, 0.76, 0.45, 0.01]
Отсортированный массив: [0.01, 0.12, 0.23, 0.34, 0.45, 0.56, 0.65, 0.76, 0.89, 0.98]

Объяснение работы алгоритма
               
Проверка крайних случаев
Если массив пуст (len(arr) == 0), возвращаем его.
Если все элементы одинаковы (min_val == max_val), массив уже отсортирован.
Создание корзин (buckets = [[] for _ in range(num_buckets)])
Формируется список из num_buckets пустых списков (корзин).
Сортировка каждой корзины (for bucket in buckets: insertion_sort(bucket))
Каждая корзина сортируется отдельно с помощью алгоритма сортировки вставками (insertion_sort).
Объединение корзин ( sorted_arr = []
    for bucket in buckets:
        sorted_arr.extend(bucket))
Все элементы из корзин последовательно добавляются в итоговый массив sorted_arr.


Оценка временной сложности в нотации Big(O)
               
Лучшая и средняя сложность: O(n+k)
Худшая сложность: O(n2)
где:
n — количество элементов в массиве;
k — количество корзин.              



Краткое объяснение оценки сложности
               
Лучшая/средняя сложность O(n+k) достигается, когда:
элементы равномерно распределены по корзинам;
в каждой корзине мало элементов (близко к n/k);
сортировка каждой корзины (вставками) выполняется за O((n/k)2), но в сумме по всем корзинам это даёт O(n).
Худшая сложность O(n2) возникает, если:
все элементы попадают в одну корзину (например, при неудачном выборе num_buckets или неравномерном распределении данных);
тогда сортировка этой корзины вставками займёт O(n2).



2. Блинная сортировка

Определение алгоритма
Блинная сортировка (англ. Pancake sorting) — алгоритм сортировки, в котором единственная разрешённая операция — переворот (flip) префикса массива (первых k элементов). 
Цель — отсортировать массив по возрастанию, используя минимальное число переворотов.
Название связано с аналогией: представьте стопку блинов разной толщины, которую нужно упорядочить по размеру, переворачивая верхние k блинов за один раз.

Код

def pancake_sort(arr):
    """
    Сортировка блинным методом (pancake sort).
    
    Параметры:
        arr (list): список чисел для сортировки
    
    Возвращает:
        list: отсортированный список по возрастанию
    """
    n = len(arr)  # Получаем длину массива
    
    # Проходим по всем позициям от конца к началу
    for curr_size in range(n, 1, -1):
        # Находим индекс максимального элемента в неотсортированной части
        max_idx = arr.index(max(arr[:curr_size]))
        
        # Если максимальный элемент не на своём месте (не в конце текущей части)
        if max_idx != curr_size - 1:
            # Если максимальный элемент не в начале, переворачиваем его в начало
            if max_idx != 0:
                # Переворачиваем префикс до max_idx + 1
                arr[:max_idx + 1] = arr[:max_idx + 1][::-1]
                # print(f"Переворот до {max_idx + 1}: {arr}")  # Для отладки
            
            # Теперь максимальный элемент в начале — переворачиваем всю текущую часть
            arr[:curr_size] = arr[:curr_size][::-1]
            # print(f"Переворот всей части {curr_size}: {arr}")  # Для отладки
    
    return arr



# Пример использования
if __name__ == "__main__":
    # Исходный массив
    data = [3, 6, 1, 9, 4, 2]
    print(f"Исходный массив: {data}")
    
    # Сортируем
    sorted_data = pancake_sort(data)
    
    print(f"Отсортированный массив: {sorted_data}")


Результат работы алгоритма 

Исходный массив: [3, 6, 1, 9, 4, 2]
Отсортированный массив: [1, 2, 3, 4, 6, 9]



Объяснение работы алгоритма
               
Основная идея
Алгоритм пошагово «ставит на место» самые большие элементы, начиная с конца массива. На каждом шаге:
Находим максимальный элемент в неотсортированной части. (for curr_size in range(n, 1, -1):)
Перемещаем его в начало (если он не там).
Затем переворачиваем всю неотсортированную часть, чтобы максимальный элемент оказался в конце.
Пошаговый разбор на примере [3, 6, 1, 9, 4, 2]:
 Шаг 1 (curr_size = 6):
Максимальный элемент — 9 (индекс 3).
Переворачиваем первые 4 элемента: [9, 1, 6, 3, 4, 2].
Затем переворачиваем все 6 элементов: [2, 4, 3, 6, 1, 9].
Теперь 9 на своём месте.
 Шаг 2 (curr_size = 5):
Максимальный в [2, 4, 3, 6, 1] — 6 (индекс 3).
Переворачиваем первые 4: [6, 3, 4, 2, 1, 9].
Затем первые 5: [1, 2, 4, 3, 6, 9].
6 на месте.
Продолжаем аналогично для curr_size = 4, 3, 2.
Ключевой трюк
Два переворота позволяют поместить любой элемент на нужное место (arr[:curr_size] = arr[:curr_size][::-1]
            # print(f"Переворот всей части {curr_size}: {arr}")) :
Первый переворот — в начало.
Второй переворот — в конец текущей части




Оценка временной сложности в нотации Big(O)

Временная сложность: O(n2)
Обоснование:
Внешний цикл (for curr_size in range(n, 1, -1))
Выполняется n−1 раз (от n до 2).
→ O(n).
Переворачивание срезов (arr[:k][::-1])
Каждая операция переворота требует O(k) времени (копирование k элементов).
В худшем случае на каждой итерации выполняется два переворота:
Первый: до n элементов.
Второй: до n элементов.
Итого за все итерации: O(n2).
Суммарная сложность
Все операции внутри цикла дают O(n2), а цикл выполняется O(n) раз.
→ Общая сложность: O(n2).


Краткое объяснение оценки
              
Почему не O(nlogn)?
В отличие от быстрой сортировки или сортировки слиянием, блинная сортировка не делит массив на части. Она последовательно «выбирает» максимальный элемент, что требует полного просмотра оставшейся части на каждом шаге.
Почему O(n2)?
 n итераций внешнего цикла.
 На каждой итерации — поиск максимума и перевороты за O(n).
 Итого: n×O(n)=O(n2).
Оптимизации?
Существуют улучшенные версии (например, с поиском «ближайшего» переворота), но базовая реализация остаётся O(n2).

3.Сортировка бусинами (гравитационная)

Определение алгоритма
              
Сортировка бусинами (гравитационная сортировка, Bead Sort) — это алгоритм сортировки, имитирующий падение бусин под действием гравитации на вертикальных стержнях.
Принцип работы:
Представьте вертикальные стержни (столбцы), на которые «падают» бусины.
Каждое число в массиве соответствует количеству бусин на соответствующем стержне.
Бусины «падают вниз» под действием гравитации, заполняя нижние позиции.
После «падения» считываем количество бусин в каждом ряду снизу вверх — получаем отсортированный массив (по возрастанию).
Ограничения:
Работает только для натуральных чисел (≥ 0).
Неэффективен для больших чисел или разреженных массивов.     

Код 

def bead_sort(arr):
    """
    Сортировка бусинами (гравитационная сортировка).
    
    Параметры:
        arr (list): список натуральных чисел для сортировки
    
    Возвращает:
        list: отсортированный по возрастанию список
    """
    # Проверяем, что массив не пуст
    if not arr:
        return arr
    
    # Проверяем, что все элементы — натуральные числа (≥ 0)
    if any(x < 0 for x in arr):
        raise ValueError("Все элементы должны быть натуральными числами (≥ 0)")
    
    # Находим максимальное число — оно определит высоту «решётки»
    max_val = max(arr)
    
    # Создаём двумерную «решётку» (матрицу) из бусин
    # Строки — уровни, столбцы — стержни
    # Изначально все ячейки заполнены нулями (нет бусин)
    beads = [[0] * max_val for _ in range(len(arr))]
    
    # «Размещаем» бусины на стержнях
    # Для каждого числа из входного массива:
    # - берём соответствующий стержень (столбец)
    # - ставим бусины на нижние `arr[i]` позиций
    for i, num in enumerate(arr):
        for j in range(num):
            beads[i][j] = 1  # 1 = есть бусина
    
    # «Гравитация»: бусины падают вниз
    # Для каждого уровня (строки) считаем количество бусин
    # и заполняем нижний ряд этим количеством бусин
    for j in range(max_val):  # для каждого столбца
        total_beads = sum(beads[i][j] for i in range(len(arr)))  # считаем бусины в столбце
        
        # Очищаем столбец
        for i in range(len(arr)):
            beads[i][j] = 0
        
        # Заполняем нижние `total_beads` позиций бусинами
        for i in range(total_beads):
            beads[len(arr) - 1 - i][j] = 1  # снизу вверх
    
    # Считываем результат: для каждого стержня считаем количество бусин
    sorted_arr = []
    for i in range(len(arr)):
        # Считаем бусины на стержне i
        bead_count = sum(beads[i][j] for j in range(max_val))
        sorted_arr.append(bead_count)
    
    return sorted_arr



# Пример использования
if __name__ == "__main__":
    # Тестовый массив
    test_array = [5, 3, 1, 7, 4, 1, 2]
    print("Исходный массив:", test_array)
    
    # Сортируем
    result = bead_sort(test_array)
    print("Отсортированный массив:", result)



Результат работы алгоритма 

Исходный массив: [5, 3, 1, 7, 4, 1, 2]
Отсортированный массив: [1, 1, 2, 3, 4, 5, 7]


Объяснение работы алгоритма
                         
 Инициализация
Проверяем входные данные (не пустой массив, только ≥ 0).
Находим max_val — максимальное число определяет высоту «решётки».
 Размещение бусин
#(beads = [[0] * max_val for _ in range(len(arr))])
Создаём матрицу beads размером len(arr) × max_val.
Для каждого числа arr[i] ставим arr[i] бусин на стержень i (в нижние позиции).
 Гравитация (падение бусин) 
#(for i, num in enumerate(arr):
        for j in range(num):
            beads[i][j] = 1  # 1 = есть бусина)                        
Для каждого столбца (уровня) считаем общее количество бусин.
 Очищаем столбец.
#(for i in range(len(arr)):
            beads[i][j] = 0)
Заполняем нижние позиции этого столбца бусинами (имитируем падение).
 Считывание результата
#(sorted_arr = []
    for i in range(len(arr)):
        # Считаем бусины на стержне i
        bead_count = sum(beads[i][j] for j in range(max_val))
        sorted_arr.append(bead_count))                         
Для каждого стержня считаем количество бусин — это и есть отсортированное значение.
Собираем массив из этих значений.       


Оценка временной сложности (Big O)
                         
Временная сложность: O(n⋅m), где:
n — количество элементов в массиве,
m — максимальное значение в массиве.
Пояснение:
Поиск max_val: O(n).
Создание матрицы: O(n⋅m).
Размещение бусин: O(n⋅m) (в худшем случае каждое число ≈ m).
Гравитация: O(m⋅n) (для каждого из m столбцов проходим n строк).
Считывание результата: O(n⋅m).
Итого: доминирующий член — O(n⋅m).



Краткое объяснение оценки
                         
Алгоритм зависит не только от количества элементов (n), но и от величины чисел (m).
Для массивов с большими числами (например, [1, 1000, 2]) сложность резко растёт, так как матрица будет очень высокой.
В лучшем случае (маленькие числа) — близко к O(n 2).
В худшем случае (большие числа) — O(n⋅m), что может быть намного хуже классических алгоритмов (O(nlogn)).




4. Поиск скачками (Jump Search)        

Определение алгоритма Jump Search
                          
Jump Search (поиск скачками) — это алгоритм поиска в отсортированном массиве, который сочетает линейный и бинарный поиск.
Он «перепрыгивает» через фиксированное число элементов, пока не найдёт участок, где может находиться искомый элемент, затем выполняет линейный поиск в этом участке.

Код

import math

def jump_search(arr, target):
    """
    Алгоритм поиска скачками (Jump Search) в отсортированном массиве.
    
    Параметры:
    arr (list): отсортированный список чисел
    target (int/float): искомое значение
    
    Возвращает:
    int: индекс элемента в массиве, если найден; -1, если не найден
    """
    n = len(arr)  # Получаем длину массива
    
    # Если массив пуст, элемент не найден
    if n == 0:
        return -1
    
    # Определяем размер «прыжка» — оптимальный равен корню из длины массива
    step = int(math.sqrt(n))
    
    # Начальный индекс для прыжков
    prev = 0
    
    # «Прыгаем» по массиву, пока не найдём участок, где может быть target
    # или пока не выйдем за границы массива
    while prev + step < n and arr[prev + step] < target:
        prev += step  # Переходим к следующему блоку
    
    # Теперь мы знаем, что target находится между prev и prev + step
    # Выполняем линейный поиск в этом диапазоне
    for i in range(prev, min(prev + step + 1, n)):
        if arr[i] == target:
            return i  # Возвращаем индекс найденного элемента
    
    # Если элемент не найден, возвращаем -1
    return -1


# Пример использования алгоритма
if __name__ == "__main__":
    # Отсортированный массив для поиска
    sorted_array = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25]
    target_value = 17
    
    # Вызываем функцию поиска
    result = jump_search(sorted_array, target_value)
    
    # Выводим результат
    if result != -1:
        print(f"Элемент {target_value} найден на позиции {result}")
    else:
        print(f"Элемент {target_value} не найден в массиве")




Результат работы алгоритма 

Элемент 17 найден на позиции 8


Объяснение работы алгоритма

 Инициализация
Получаем длину массива n.  (n = len(arr)) 
Проверяем, не пуст ли массив.
Вычисляем размер «прыжка» как  n — это оптимальный шаг для минимизации количества операций. (step = int(math.sqrt(n)))
 Фаза прыжков
Начинаем с индекса prev = 0.
«Прыгаем» на step элементов вперёд, пока:
не выйдем за границы массива (prev + step < n),
значение в позиции arr[prev + step] меньше искомого target.
Когда условие нарушается, мы нашли блок, в котором может находиться target.
 Фаза линейного поиска (for i in range(prev, min(prev + step + 1, n)):
        if arr[i] == target:
            return i )
В найденном блоке (от prev до prev + step) выполняем обычный линейный поиск.
Если находим target, возвращаем его индекс.
Если не находим, возвращаем -1.


Оценка временной сложности в нотации Big‑O
Оптимальное количество прыжков составляет около 
N1/2  (где N — длина массива), а линейный поиск в одном блоке тоже требует максимум N операций. Таким образом, итоговая временная сложность: O(N1/2)



                          
Краткое объяснение оценки
                          
При поиске методом прыжков мы делаем около N1/2
​больших прыжков и потом ещё около N1/2
мелких проверок в конце. Поэтому оба компонента работают вместе в рамках одной и той же асимптотической зависимости. Такое поведение гораздо лучше обычного линейного поиска 
O(N), хотя менее эффективно, чем бинарный поиск O(logN).
Однако алгоритм прост в реализации и хорошо подходит для небольших размеров массива или случаев, когда бинарный поиск реализовать сложно или неэффективно.




5. Экспоненциальный поиск (Exponential Search)

Определение алгоритма
                          
Экспоненциальный поиск (Exponential Search) — алгоритм поиска элемента в отсортированном массиве, сочетающий:
Экспоненциальное расширение диапазона — быстрый поиск границ, в которых может находиться искомый элемент (путём удвоения индекса).
Бинарный поиск — точный поиск внутри найденного диапазона.
Алгоритм эффективен, когда искомый элемент находится ближе к началу массива, так как быстро «нащупывает» подходящую область.


Код

def exponential_search(arr, target):
    """
    Экспоненциальный поиск элемента в отсортированном массиве.
    
    Параметры:
        arr (list): отсортированный список чисел
        target (int/float): искомое значение
    
    Возвращает:
        int: индекс элемента, если найден; -1, если не найден
    """
    n = len(arr)  # Длина массива
    
    # Базовый случай: массив пуст
    if n == 0:
        return -1
    
    # Если элемент находится на первой позиции
    if arr[0] == target:
        return 0
    
    # Находим границу диапазона, где может находиться target
    # Начинаем с индекса 1 и удваиваем его, пока не выйдем за границы
    # или пока arr[i] <= target
    i = 1
    while i < n and arr[i] <= target:
        i *= 2  # Удваиваем индекс: 1 → 2 → 4 → 8 → ...
    
    # Теперь искомый элемент точно находится в диапазоне [i//2, min(i, n-1)]
    # Применяем бинарный поиск в этом диапазоне
    left = i // 2      # Нижняя граница диапазона
    right = min(i, n - 1)  # Верхняя граница диапазона
    
    return binary_search(arr, target, left, right)



def binary_search(arr, target, left, right):
    """
    Бинарный поиск в заданном диапазоне массива.
    
    Параметры:
        arr (list): отсортированный список
        target (int/float): искомое значение
        left (int): левая граница диапазона
        right (int): правая граница диапазона
    
    Возвращает:
        int: индекс элемента, если найден; -1, если не найден
    """
    while left <= right:
        mid = (left + right) // 2  # Средний индекс
        
        if arr[mid] == target:
            return mid  # Элемент найден
        elif arr[mid] < target:
            left = mid + 1  # Ищем в правой




Результат работы алгоритма 

Элемент 13 найден на индексе 6



Объяснение работы алгоритма

Шаг 1: Начальная проверка первого элемента
Сначала проверяется, совпадает ли первый элемент массива с искомым элементом. Это ускорит выполнение алгоритма, если элемент находится именно там.
(if arr[0] == x:
    return 0)
Если условие выполнено, значит элемент найден сразу же, и дальнейшие вычисления не нужны.
Шаг 2: Увеличиваем зону поиска экспоненциально
Затем начинаем экспоненциально увеличивать область поиска, начиная с первой позиции. Мы двигаемся вперед, постоянно удваивая индекс (i), пока не встретим одно из условий остановки:
Мы достигли конца массива (i >= n)
Следующее значение в массиве стало больше искомого элемента (arr[i] > x)
Например, если массив имеет вид [10,20,30,40,50,60] и мы ищем число 60, 
то на первом этапе индекс увеличивается до тех пор, пока не найдём подходящую точку начала бинарного поиска: (while i < n and arr[i] <= x: i *= 2)
Шаг 3: Бинарный поиск в ограниченной зоне
Теперь, когда найдено приблизительное положение искомого элемента, выполняется обычный бинарный поиск в диапазоне от половины последней точки до фактического положения, достигнутого ранее.
Задача бинарного поиска — точно определить местоположение элемента в полученной ограниченной зоне. Например, если последний шаг остановился на индексе 
4, то теперь нам достаточно искать в интервале от 2 до 4 включительно. (index = binary_search(arr, i // 2, min(i, n - 1), x))
По окончании обоих этапов программа возвращает индекс найденного элемента или −1, если элемент не обнаружен.


                          
Временная сложность в нотации Big-O
                          
Время работы экспоненциального поиска можно выразить следующим образом:O(log i+logN),
O(logi+logN),
где:
logi — количество шагов экспоненциального увеличения области поиска (поскольку мы умножаем индекс на два);
logN — время работы стандартного бинарного поиска в конечной выбранной области.
Таким образом, общая временная сложность составляет примерно:
O(logN)



Краткое объяснение оценки

Поскольку экспоненциальный поиск быстро увеличивает длину исследуемого участка (двойное увеличение на каждом шаге), фактически общее количество итераций экспоненциального этапа ограничено логарифмом размера массива (logN). 
А далее применяется бинарный поиск, также имеющий сложность порядка logN. 
Следовательно, суммарная сложность остается линейно зависящей от логарифма размера массива, что аналогично обычному бинарному поиску.
Итоговая оценка показывает, что экспоненциальный поиск эффективен и сравним по производительности с обычным бинарным поиском, но обладает преимуществами при работе с большими объемами данных или неопределенными размерами массивов.




























                          
                          
