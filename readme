1. Блочная (корзинная) сортировка

Определение 

Определение алгоритма
Блочная (корзинная) сортировка (Bucket Sort) — это алгоритм сортировки, который:
распределяет элементы входного массива по фиксированному числу «корзин» (блоков) на основе их значений;
сортирует каждую корзину отдельно (часто с помощью сортировки вставками);
объединяет отсортированные корзины в единый упорядоченный массив.
Оптимально работает при равномерном распределении данных по диапазону значений.



Объяснение работы алгоритма
               
Проверка крайних случаев
Если массив пуст (len(arr) == 0), возвращаем его.
Если все элементы одинаковы (min_val == max_val), массив уже отсортирован.
Создание корзин (buckets = [[] for _ in range(num_buckets)])
Формируется список из num_buckets пустых списков (корзин).
Сортировка каждой корзины (for bucket in buckets: insertion_sort(bucket))
Каждая корзина сортируется отдельно с помощью алгоритма сортировки вставками (insertion_sort).
Объединение корзин ( sorted_arr = []
    for bucket in buckets:
        sorted_arr.extend(bucket))
Все элементы из корзин последовательно добавляются в итоговый массив sorted_arr.


Оценка временной сложности в нотации Big(O)
               
Лучшая и средняя сложность: O(n+k)
Худшая сложность: O(n2)
где:
n — количество элементов в массиве;
k — количество корзин.              



Краткое объяснение оценки сложности
               
Лучшая/средняя сложность O(n+k) достигается, когда:
элементы равномерно распределены по корзинам;
в каждой корзине мало элементов (близко к n/k);
сортировка каждой корзины (вставками) выполняется за O((n/k)2), но в сумме по всем корзинам это даёт O(n).
Худшая сложность O(n2) возникает, если:
все элементы попадают в одну корзину (например, при неудачном выборе num_buckets или неравномерном распределении данных);
тогда сортировка этой корзины вставками займёт O(n2).



2. Блинная сортировка

Определение алгоритма
Блинная сортировка (англ. Pancake sorting) — алгоритм сортировки, в котором единственная разрешённая операция — переворот (flip) префикса массива (первых k элементов). 
Цель — отсортировать массив по возрастанию, используя минимальное число переворотов.
Название связано с аналогией: представьте стопку блинов разной толщины, которую нужно упорядочить по размеру, переворачивая верхние k блинов за один раз.



Объяснение работы алгоритма
               
Основная идея
Алгоритм пошагово «ставит на место» самые большие элементы, начиная с конца массива. На каждом шаге:
Находим максимальный элемент в неотсортированной части. (for curr_size in range(n, 1, -1):)
Перемещаем его в начало (если он не там).
Затем переворачиваем всю неотсортированную часть, чтобы максимальный элемент оказался в конце.
Пошаговый разбор на примере [3, 6, 1, 9, 4, 2]:
 Шаг 1 (curr_size = 6):
Максимальный элемент — 9 (индекс 3).
Переворачиваем первые 4 элемента: [9, 1, 6, 3, 4, 2].
Затем переворачиваем все 6 элементов: [2, 4, 3, 6, 1, 9].
Теперь 9 на своём месте.
 Шаг 2 (curr_size = 5):
Максимальный в [2, 4, 3, 6, 1] — 6 (индекс 3).
Переворачиваем первые 4: [6, 3, 4, 2, 1, 9].
Затем первые 5: [1, 2, 4, 3, 6, 9].
6 на месте.
Продолжаем аналогично для curr_size = 4, 3, 2.
Ключевой трюк
Два переворота позволяют поместить любой элемент на нужное место (arr[:curr_size] = arr[:curr_size][::-1]
            # print(f"Переворот всей части {curr_size}: {arr}")) :
Первый переворот — в начало.
Второй переворот — в конец текущей части




Оценка временной сложности в нотации Big(O)

Временная сложность: O(n2)
Обоснование:
Внешний цикл (for curr_size in range(n, 1, -1))
Выполняется n−1 раз (от n до 2).
→ O(n).
Переворачивание срезов (arr[:k][::-1])
Каждая операция переворота требует O(k) времени (копирование k элементов).
В худшем случае на каждой итерации выполняется два переворота:
Первый: до n элементов.
Второй: до n элементов.
Итого за все итерации: O(n2).
Суммарная сложность
Все операции внутри цикла дают O(n2), а цикл выполняется O(n) раз.
→ Общая сложность: O(n2).


Краткое объяснение оценки
              
Почему не O(nlogn)?
В отличие от быстрой сортировки или сортировки слиянием, блинная сортировка не делит массив на части. Она последовательно «выбирает» максимальный элемент, что требует полного просмотра оставшейся части на каждом шаге.
Почему O(n2)?
 n итераций внешнего цикла.
 На каждой итерации — поиск максимума и перевороты за O(n).
 Итого: n×O(n)=O(n2).
Оптимизации?
Существуют улучшенные версии (например, с поиском «ближайшего» переворота), но базовая реализация остаётся O(n2).

3.Сортировка бусинами (гравитационная)

Определение алгоритма
              
Сортировка бусинами (гравитационная сортировка, Bead Sort) — это алгоритм сортировки, имитирующий падение бусин под действием гравитации на вертикальных стержнях.
Принцип работы:
Представьте вертикальные стержни (столбцы), на которые «падают» бусины.
Каждое число в массиве соответствует количеству бусин на соответствующем стержне.
Бусины «падают вниз» под действием гравитации, заполняя нижние позиции.
После «падения» считываем количество бусин в каждом ряду снизу вверх — получаем отсортированный массив (по возрастанию).
Ограничения:
Работает только для натуральных чисел (≥ 0).
Неэффективен для больших чисел или разреженных массивов.     




Объяснение работы алгоритма
                         
 Инициализация
Проверяем входные данные (не пустой массив, только ≥ 0).
Находим max_val — максимальное число определяет высоту «решётки».
 Размещение бусин
#(beads = [[0] * max_val for _ in range(len(arr))])
Создаём матрицу beads размером len(arr) × max_val.
Для каждого числа arr[i] ставим arr[i] бусин на стержень i (в нижние позиции).
 Гравитация (падение бусин) 
#(for i, num in enumerate(arr):
        for j in range(num):
            beads[i][j] = 1  # 1 = есть бусина)                        
Для каждого столбца (уровня) считаем общее количество бусин.
 Очищаем столбец.
#(for i in range(len(arr)):
            beads[i][j] = 0)
Заполняем нижние позиции этого столбца бусинами (имитируем падение).
 Считывание результата
#(sorted_arr = []
    for i in range(len(arr)):
        # Считаем бусины на стержне i
        bead_count = sum(beads[i][j] for j in range(max_val))
        sorted_arr.append(bead_count))                         
Для каждого стержня считаем количество бусин — это и есть отсортированное значение.
Собираем массив из этих значений.       


Оценка временной сложности (Big O)
                         
Временная сложность: O(n⋅m), где:
n — количество элементов в массиве,
m — максимальное значение в массиве.
Пояснение:
Поиск max_val: O(n).
Создание матрицы: O(n⋅m).
Размещение бусин: O(n⋅m) (в худшем случае каждое число ≈ m).
Гравитация: O(m⋅n) (для каждого из m столбцов проходим n строк).
Считывание результата: O(n⋅m).
Итого: доминирующий член — O(n⋅m).



Краткое объяснение оценки
                         
Алгоритм зависит не только от количества элементов (n), но и от величины чисел (m).
Для массивов с большими числами (например, [1, 1000, 2]) сложность резко растёт, так как матрица будет очень высокой.
В лучшем случае (маленькие числа) — близко к O(n 2).
В худшем случае (большие числа) — O(n⋅m), что может быть намного хуже классических алгоритмов (O(nlogn)).




4. Поиск скачками (Jump Search)        

Определение алгоритма Jump Search
                          
Jump Search (поиск скачками) — это алгоритм поиска в отсортированном массиве, который сочетает линейный и бинарный поиск.
Он «перепрыгивает» через фиксированное число элементов, пока не найдёт участок, где может находиться искомый элемент, затем выполняет линейный поиск в этом участке.



Объяснение работы алгоритма

 Инициализация
Получаем длину массива n.  (n = len(arr)) 
Проверяем, не пуст ли массив.
Вычисляем размер «прыжка» как  n — это оптимальный шаг для минимизации количества операций. (step = int(math.sqrt(n)))
 Фаза прыжков
Начинаем с индекса prev = 0.
«Прыгаем» на step элементов вперёд, пока:
не выйдем за границы массива (prev + step < n),
значение в позиции arr[prev + step] меньше искомого target.
Когда условие нарушается, мы нашли блок, в котором может находиться target.
 Фаза линейного поиска (for i in range(prev, min(prev + step + 1, n)):
        if arr[i] == target:
            return i )
В найденном блоке (от prev до prev + step) выполняем обычный линейный поиск.
Если находим target, возвращаем его индекс.
Если не находим, возвращаем -1.


Оценка временной сложности в нотации Big‑O
Оптимальное количество прыжков составляет около 
N1/2  (где N — длина массива), а линейный поиск в одном блоке тоже требует максимум N операций. Таким образом, итоговая временная сложность: O(N1/2)



                          
Краткое объяснение оценки
                          
При поиске методом прыжков мы делаем около N1/2
​больших прыжков и потом ещё около N1/2
мелких проверок в конце. Поэтому оба компонента работают вместе в рамках одной и той же асимптотической зависимости. Такое поведение гораздо лучше обычного линейного поиска 
O(N), хотя менее эффективно, чем бинарный поиск O(logN).
Однако алгоритм прост в реализации и хорошо подходит для небольших размеров массива или случаев, когда бинарный поиск реализовать сложно или неэффективно.




5. Экспоненциальный поиск (Exponential Search)

Определение алгоритма
                          
Экспоненциальный поиск (Exponential Search) — алгоритм поиска элемента в отсортированном массиве, сочетающий:
Экспоненциальное расширение диапазона — быстрый поиск границ, в которых может находиться искомый элемент (путём удвоения индекса).
Бинарный поиск — точный поиск внутри найденного диапазона.
Алгоритм эффективен, когда искомый элемент находится ближе к началу массива, так как быстро «нащупывает» подходящую область.





Объяснение работы алгоритма

Шаг 1: Начальная проверка первого элемента
Сначала проверяется, совпадает ли первый элемент массива с искомым элементом. Это ускорит выполнение алгоритма, если элемент находится именно там.
(if arr[0] == x:
    return 0)
Если условие выполнено, значит элемент найден сразу же, и дальнейшие вычисления не нужны.
Шаг 2: Увеличиваем зону поиска экспоненциально
Затем начинаем экспоненциально увеличивать область поиска, начиная с первой позиции. Мы двигаемся вперед, постоянно удваивая индекс (i), пока не встретим одно из условий остановки:
Мы достигли конца массива (i >= n)
Следующее значение в массиве стало больше искомого элемента (arr[i] > x)
Например, если массив имеет вид [10,20,30,40,50,60] и мы ищем число 60, 
то на первом этапе индекс увеличивается до тех пор, пока не найдём подходящую точку начала бинарного поиска: (while i < n and arr[i] <= x: i *= 2)
Шаг 3: Бинарный поиск в ограниченной зоне
Теперь, когда найдено приблизительное положение искомого элемента, выполняется обычный бинарный поиск в диапазоне от половины последней точки до фактического положения, достигнутого ранее.
Задача бинарного поиска — точно определить местоположение элемента в полученной ограниченной зоне. Например, если последний шаг остановился на индексе 
4, то теперь нам достаточно искать в интервале от 2 до 4 включительно. (index = binary_search(arr, i // 2, min(i, n - 1), x))
По окончании обоих этапов программа возвращает индекс найденного элемента или −1, если элемент не обнаружен.


                          
Временная сложность в нотации Big-O
                          
Время работы экспоненциального поиска можно выразить следующим образом:O(log i+logN),
O(logi+logN),
где:
logi — количество шагов экспоненциального увеличения области поиска (поскольку мы умножаем индекс на два);
logN — время работы стандартного бинарного поиска в конечной выбранной области.
Таким образом, общая временная сложность составляет примерно:
O(logN)



Краткое объяснение оценки

Поскольку экспоненциальный поиск быстро увеличивает длину исследуемого участка (двойное увеличение на каждом шаге), фактически общее количество итераций экспоненциального этапа ограничено логарифмом размера массива (logN). 
А далее применяется бинарный поиск, также имеющий сложность порядка logN. 
Следовательно, суммарная сложность остается линейно зависящей от логарифма размера массива, что аналогично обычному бинарному поиску.
Итоговая оценка показывает, что экспоненциальный поиск эффективен и сравним по производительности с обычным бинарным поиском, но обладает преимуществами при работе с большими объемами данных или неопределенными размерами массивов.


6. Тернарный поиск (Ternary Search)

Определение алгоритма
Тернарный поиск (Ternary Search) — это алгоритм поиска элемента в отсортированном массиве, который делит область поиска не на 2 части (как бинарный поиск), а на 3 равные части. На каждом шаге алгоритм определяет, в какой из трёх частей может находиться искомый элемент, и продолжает поиск только в этой части.
Алгоритм применим только к монотонным (возрастающим или убывающим) массивам.

Код

def ternary_search(arr, target):
    """
    Тернарный поиск элемента в отсортированном массиве.
    
    Параметры:
        arr (list): отсортированный список чисел
        target (int/float): искомое значение
    
    Возвращает:
        int: индекс элемента, если найден; -1, если не найден
    """
    left = 0                    # Левая граница поиска (начальный индекс)
    right = len(arr) - 1      # Правая граница поиска (конечный индекс)
    
    # Цикл продолжается, пока границы не пересекутся
    while left <= right:
        # Делим отрезок [left, right] на 3 части
        # Вычисляем две точки разделения
        mid1 = left + (right - left) // 3   # Первая точка деления (1/3 отрезка)
        mid2 = right - (right - left) // 3    # Вторая точка деления (2/3 отрезка)
        
        # Проверяем, совпадает ли искомое значение с элементами в точках деления
        if arr[mid1] == target:
            return mid1  # Нашли элемент, возвращаем его индекс
        
        if arr[mid2] == target:
            return mid2  # Нашли элемент, возвращаем его индекс
        
        # Определяем, в какой из трёх частей может быть target
        if target < arr[mid1]:
            # target лежит в левой трети: [left, mid1 - 1]
            right = mid1 - 1
        elif target > arr[mid2]:
            # target лежит в правой трети: [mid2 + 1, right]
            left = mid2 + 1
        else:
            # target лежит в средней трети: [mid1 + 1, mid2 - 1]
            left = mid1 + 1
            right = mid2 - 1
    
    # Элемент не найден
    return -1



# Пример использования
if __name__ == "__main__":
    # Отсортированный массив для поиска
    array = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
    target = 7
    
    result = ternary_search(array, target)
    
    if result != -1:
        print(f"Элемент {target} найден на позиции {result}")
    else:
        print(f"Элемент {target} не найден в массиве")


Результат работы алгоритма

Элемент 7 найден на позиции 3



Объяснение работы алгоритма

Инициализация границ
left = 0 — начало массива.
right = len(arr) - 1 — конец массива.
Деление на три части
mid1 = left + (right - left) // 3 — точка на 1/3 пути от left к right.
mid2 = right - (right - left) // 3 — точка на 2/3 пути.
Проверка точек деления
Если arr[mid1] == target или arr[mid2] == target — элемент найден, возвращаем индекс.
Сужение области поиска
Если target < arr[mid1] → ищем в левой трети (right = mid1 - 1).
Если target > arr[mid2] → ищем в правой трети (left = mid2 + 1).
Иначе → ищем в средней трети (left = mid1 + 1, right = mid2 - 1).
Повторение
Цикл продолжается, пока left <= right.
Если элемент не найден, возвращается -1.



Оценка временной сложности (Big O)

Временная сложность: O(log 3 n)
Пояснение:
На каждой итерации алгоритм уменьшает область поиска в 3 раза.
Количество итераций ≈ log 3 n, где n — длина массива.
Каждая итерация выполняет O(1) операций (сравнения, арифметические действия).
Итого: O(log 3 n).


Краткое объяснение оценки сложности
Логарифмическая сложность возникает из-за многократного деления области поиска.
Основание логарифма — 3, потому что массив делится на 3 части.
O(log 3 n) означает, что число шагов растёт очень медленно с увеличением n (например, для n=1000000 потребуется всего ~12–13 шагов).
Алгоритм эффективен для больших отсортированных массивов, но не оптимален по числу сравнений.







                          
                          
