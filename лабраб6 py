Быстрая сортировка (Quick Sort)
def quick_sort(arr):
    """
    Функция осуществляет быструю сортировку массива.
    :param arr: Список элементов для сортировки
    :return: Отсортированный список
    """
    if len(arr) <= 1:  # Базовый случай: пустой или односимвольный массив уже отсортированы
        return arr
    
    pivot = arr[len(arr) // 2]  # Берём средний элемент массива в качестве опорного
    
    # Формируем три списка: элементы меньше опорного, равные и больше опорного
    less = [x for x in arr if x < pivot]  # Все элементы, меньшие опорного
    equal = [x for x in arr if x == pivot]  # Все элементы, равные опорному
    greater = [x for x in arr if x > pivot]  # Все элементы, большие опорного
    
    # Рекурсивно сортируем списки "less" и "greater"
    return quick_sort(less) + equal + quick_sort(greater)

# Тестируем алгоритм
if __name__ == "__main__":
    unsorted_list = [3, 6, 8, 10, 1, 2, 1]
    sorted_list = quick_sort(unsorted_list)
    print(f'Исходный массив: {unsorted_list}')
    print(f'Отсортированный массив: {sorted_list}')

Исходный массив: [3, 6, 8, 10, 1, 2, 1]
Отсортированный массив: [1, 1, 2, 3, 6, 8, 10]


[Execution Finished]










Сортировка Шелла 
def shell_sort(arr):
    # Получение размера массива
    n = len(arr)
    
    # Выбор последовательности шагов (пример Хиббарда)
    gap = n // 2  # Первый шаг берется как половина длины массива
    
    # Продолжаем уменьшать шаг, пока он не станет нулевым
    while gap > 0:
        # Внешний цикл идет по всей длине массива, учитывая текущий шаг
        for i in range(gap, n):
            temp = arr[i]  # Сохраняем текущий элемент
            
            # Внутренний цикл движется назад по массиву, сравнивая элементы
            j = i
            while j >= gap and arr[j-gap] > temp:
                # Если предыдущий элемент больше текущего, сдвигаем его вперед
                arr[j] = arr[j-gap]
                j -= gap
                
            # Вставляем текущий элемент в нужное место
            arr[j] = temp
        
        # Уменьшаем шаг вдвое
        gap //= 2

# Тестирование алгоритма
if __name__ == "__main__":
    test_array = [64, 34, 25, 12, 22, 11, 90]
    print("Исходный массив:", test_array)
    
    shell_sort(test_array)
    
    print("Отсортированный массив:", test_array)


Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]


[Execution Finished]














ЗАНОВО
Бинарный поиск
def binary_search(arr, target):
    # Определяем начальные границы диапазона поиска
    left = 0            # Левая граница начинается с первого индекса
    right = len(arr) - 1   # Правая граница равна последнему индексу

    while left <= right:      # Пока левая граница меньше или равна правой границе
        mid = (left + right) // 2     # Вычисляем средний индекс, используя целочисленное деление
        
        if arr[mid] == target:       # Если элемент найден на средней позиции
            return mid               # Возвращаем индекс найденного элемента
            
        elif arr[mid] < target:      # Если целевой элемент больше среднего значения
            left = mid + 1           # Обновляем левую границу на позицию справа от середины
            
        else:                        # Иначе, если целевой элемент меньше среднего значения
            right = mid - 1          # Обновляем правую границу на позицию слева от середины
    
    return None                     # Если элемент не найден, возвращаем None


# Пример использования
sorted_array = [1, 3, 5, 7, 9, 11, 13]
target_value = 7

result = binary_search(sorted_array, target_value)
if result is not None:
    print(f'Элемент {target_value} найден на индексе {result}')
else:
    print('Элемент не найден')








Поиск по Фибоначчи
import math

# Вспомогательная функция для вычисления наименьшего числа Фибоначчи,
# которое больше или равно длине массива
def fibonacci_number_greater_than_or_equal_to_length(length):
    f1, f2 = 0, 1
    while f2 < length:
        temp = f2
        f2 += f1
        f1 = temp
    return f2

# Основной алгоритм поиска по Фибоначчи
def fibonacci_search(arr, target):
    m = fibonacci_number_greater_than_or_equal_to_length(len(arr))  # Получаем подходящее число Фибоначчи
    offset = -1                                                     # Смещение начальной позиции
    f_minus_two = 0                                                 # F(k-2)
    f_minus_one = 1                                                 # F(k-1)
    while m > 1:
        i = min(offset+f_minus_two, len(arr)-1)                      # Индекс для проверки
        if arr[i] < target:                                          # Если элемент меньше цели
            m = f_minus_one                                         # Переходим к следующему числу Фибоначчи
            f_minus_two = f_minus_one                               # Обновляем предыдущие числа
            f_minus_one = m - f_minus_two                           # Следующее число Фибоначчи
            offset = i                                              # Изменяем смещение
        elif arr[i] > target:                                       # Если элемент больше цели
            m = f_minus_two                                        # Переход к предыдущему числу Фибоначчи
            f_minus_one -= f_minus_two                             # Обновляем предыдущее число
            f_minus_two = m - f_minus_one                          # Новое следующее число Фибоначчи
        else:                                                       # Если элемент равен цели
            return i                                                # Возврат индекса
    # Последний возможный случай сравнения
    if f_minus_one and arr[offset+1]==target:
        return offset+1                                             # Проверка последнего возможного места
    return -1                                                      # Если элемент не найден

# Тестирование
array = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
search_element = 85
index = fibonacci_search(array, search_element)

if index != -1:
    print("Элемент {} найден на индексе {}".format(search_element, index))
else:
    print("Элемент не найден")
