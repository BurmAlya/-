СОРТИРОВКА ВЫБОРОМ НА С++:
Алгоритм сортировки выбором проходит по массиву, на каждой итерации находя минимальный элемент и меняя его местами с первым элементом текущей несортированной части. Данный процесс повторяется, пока весь массив не будет отсортирован. Временная сложность алгоритма всегда равна O(n^2), независимо от состояния массива. Хотя сортировка выбором проста в реализации, она крайне неэффективна для больших объемов данных.


СОРТИРОВКА ОБМЕНОМ (ПУЗЫРЬКОМ):
Алгоритм пузырьковой сортировки многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они расположены неверно. За каждый проход наибольший элемент поднимается в конец массива, как пузырек всплывает на поверхность воды. Временная сложность этого алгоритма — O(n^2) в любых ситуациях (лучшей, средней и худшей), что делает его эффективным только для малых массивов.


СОРТИРОВКА ВСТАВКАМИ:









СОРТИРОВКА СЛИЯНИЕМ:









СОРТИРОВКА ШЕЛЛА:









БЫСТРАЯ СОРТИРОВКА:









ПИРАМИДАЛЬНАЯ СОРТИРОВКА









ПОСЛЕДОВАТЕЛЬНЫЙ ПОИСК









БИНАРНЫЙ ПОИСК









ИНТЕРПОЛИРУЮЩИЙ ПОИСК









ПОИСК ПО ФИБОНАЧЧИ




























































































































Списки в Python — динамические структуры данных, размер которых может изменяться в процессе выполнения программы. Для создания списка используются квадратные скобки, внутри которых перечисляются элементы, разделённые запятыми. 


Массивы в Java имеют фиксированный размер, который должен быть объявлен при создании массива. Для смены размера требуется создание нового массива и копирование элементов. 


Массивы в C++ — статические, размер определяется на этапе компиляции. Для изменения размера массива требуется создать новый и скопировать элементы. 
