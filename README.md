СОРТИРОВКА ВЫБОРОМ НА С++:
Алгоритм сортировки выбором проходит по массиву, на каждой итерации находя минимальный элемент и меняя его местами с первым элементом текущей несортированной части. Данный процесс повторяется, пока весь массив не будет отсортирован. Временная сложность алгоритма всегда равна O(n^2), независимо от состояния массива. Хотя сортировка выбором проста в реализации, она крайне неэффективна для больших объемов данных.


СОРТИРОВКА ОБМЕНОМ (ПУЗЫРЬКОМ):
Алгоритм пузырьковой сортировки многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они расположены неверно. За каждый проход наибольший элемент поднимается в конец массива, как пузырек всплывает на поверхность воды. Временная сложность этого алгоритма — O(n^2) в любых ситуациях (лучшей, средней и худшей), что делает его эффективным только для малых массивов.


СОРТИРОВКА ВСТАВКАМИ:
Скрипт реализует алгоритм сортировки вставками, который последовательно проходит по массиву, выбирая очередной элемент и вставляя его на нужную позицию среди уже отсортированных элементов, двигаясь назад по массиву и сдвигая большие элементы вправо. Данный процесс повторяется для каждого элемента массива, постепенно расширяя отсортированную часть. Алгоритм хорош своей интуитивностью и производительностью на частично отсортированных массивах, хотя и уступает другим алгоритмам вроде быстрой сортировки или слияния на больших объёмах данных.
Временная сложность алгоритма в Big-O-нотации составляет O(n^2) в худшем и среднем случаях, когда массив изначально сильно перемешан, и достигает наилучшего случая O(n) при работе с почти отсортированными массивами.








СОРТИРОВКА СЛИЯНИЕМ:
Представленный скрипт реализует алгоритм сортировки слиянием на языке C++. Сначала массив рекурсивно делится на две части до тех пор, пока каждая часть не сократится до одного элемента. Затем отдельные части сортируются и объединяются вместе, формируя общий отсортированный массив.
Временная сложность алгоритма сортировки слиянием в Big-O-нотации равна O(n \log n). Это достигается благодаря двум основным операциям: разбиению массива на две части, что занимает \log n, и последующему объединению этих частей, которое требует порядка n операций на каждом уровне рекурсии.








СОРТИРОВКА ШЕЛЛА:
Скрипт реализует сортировку Шелла, которая улучшает классическую сортировку вставками, предварительно располагая элементы на большем расстоянии друг от друга. Затем, постепенно уменьшая шаг, алгоритм доводит сортировку до обычного метода вставок. Средняя временная сложность такого подхода — O(n^{3/2}), но при выборе оптимальной последовательности шагов возможна оценка порядка O(n(\log n)^2).








БЫСТРАЯ СОРТИРОВКА:
Скрипт реализует алгоритм быстрой сортировки, разделяющий массив на две части относительно опорного элемента, после чего рекурсивно сортирует обе части. Оптимальное время работы алгоритма — O(n \log n), однако в худших случаях оно ухудшается до O(n^2). Среднее время работы на практике остается близким к O(n \log n), что делает алгоритм эффективным решением для большинства задач сортировки.








ПИРАМИДАЛЬНАЯ СОРТИРОВКА
Скрипт реализует пирамидальную сортировку, преобразуя массив в max-кучу, затем извлекая максимальный элемент и восстанавливая свойства кучи для оставшихся элементов. Процесс повторяется до полной сортировки массива. Временная сложность алгоритма составляет O(n \log n) в любом сценарии, что делает его надежным выбором для эффективной сортировки большого числа элементов.








ПОСЛЕДОВАТЕЛЬНЫЙ ПОИСК
Скрипт осуществляет последовательный поиск элемента в списке, проверяя каждый элемент по очереди. Если элемент найден, возвращается его индекс, иначе возвращается `-1`. Временная сложность алгоритма в худшем случае составляет O(n), где n — количество элементов в списке.








БИНАРНЫЙ ПОИСК
Скрипт реализует алгоритм бинарного поиска, который последовательно сокращает область поиска, проверяя средний элемент массива и сравнивая его с искомым значением. Временная сложность алгоритма — O(\log n), так как на каждом шаге область поиска уменьшается вдвое. Пространственная сложность — O(1), поскольку дополнительные структуры данных не создаются.








ИНТЕРПОЛИРУЮЩИЙ ПОИСК
Скрипт реализует интерполирующий поиск, улучшенный вариант бинарного поиска, который рассчитывает следующую позицию поиска, используя линейную интерполяцию и характеристику равномерного распределения элементов. Алгоритм быстрее стандартного бинарного поиска при условии равномерного распределения, имея временную сложность O(\log \log n) в среднем, но может деградировать до O(n) в худшем случае. Пространственная сложность алгоритма постоянна и равна O(1).








ПОИСК ПО ФИБОНАЧЧИ
Скрипт реализует поиск по Фибоначчи, делящий массив на участки согласно числам Фибоначчи, что потенциально повышает эффективность поиска на однородных данных. Временная сложность алгоритма — O(\log_\varphi n), где \varphi — золотое сечение, что делает его потенциально быстрее бинарного поиска в специальных случаях. Пространственная сложность — O(1), так как дополнительные структуры данных не нужны.


































































































































































