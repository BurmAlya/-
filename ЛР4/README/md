Дерево 

Дерево представляет собой особый тип графа, который характеризуется двумя ключевыми свойствами:  
- отсутствием циклов (замкнутых путей);  
- единственностью пути между любыми двумя вершинами.
Его структурные особенности:  
- выделяется одна главная вершина — *корень*;  
- остальные вершины располагаются на иерархических уровнях ниже корня;  
- рёбра ориентированы от корня к периферийным вершинам (*листьям*);  
- каждая вершина (кроме корня) имеет ровно одно входящее ребро.
Примеры применения: файловая система компьютера, генеалогические схемы, организационные структуры.


Граф 
Граф — абстрактная математическая структура, состоящая из:  
- множества *вершин* (узлов);  
- множества *рёбер* (связей), соединяющих пары вершин.
Основные разновидности графов:  
- *направленные* (орграфы) — рёбра имеют ориентацию;  
- *ненаправленные* — рёбра двусторонние;  
- *взвешенные* — каждому ребру присвоен числовой вес;  
- *невзвешенные* — рёбра не имеют весовых коэффициентов.
Практические примеры: социальные сети, транспортные схемы, электрические цепи.
Реализация структур данных
**Дерево на Python**  
```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.children = []

    def add_child(self, child):
        self.children.append(child
# Использование
root = TreeNode(1)
root.add_child(TreeNode(2))
root.add_child(TreeNode(3))
```
*Пояснение:* класс `TreeNode` моделирует узел дерева, храня его значение и список дочерних элементов. Структура легко расширяется методами для обхода, поиска и модификации.
**Граф на Java**  
```java
import java.util.ArrayList;
import java.util.List;
class GraphVertex {
    int id;
    List<GraphVertex> neighbors;

    public GraphVertex(int id) {
        this.id = id;
        this.neighbors = new ArrayList<>();
    }

    public void addNeighbor(GraphVertex vertex) {
        neighbors.add(vertex);
    }
}

// Использование
GraphVertex A = new GraphVertex(1);
GraphVertex B = new GraphVertex(2);
A.addNeighbor(B);
B.addNeighbor(A);
``
*Пояснение:* граф реализован через список смежности — каждая вершина хранит ссылки на соседние узлы. Метод экономичен по памяти и удобен для динамических изменений.
**Граф на C++**  
```cpp
#include <iostream>
#include <vector>
using namespace std;
class Vertex {
public:
    int id;
    vector<Vertex*> neighbors;

    Vertex(int id) : id(id) {}

    void addNeighbor(Vertex* neighbor) {
        neighbors.push_back(neighbor);
    }
};

// Использование
int main() {
    Vertex A(1), B(2);
    A.addNeighbor(&B);
    B.addNeighbor(&A);
    return 0;
}
```
*Пояснение:* аналогичен Java-реализации, но использует указатели для повышения производительности и снижения потребления памяти.
### Алгоритм обхода дерева (DFS)
**Реализация на Python**  
```python
def dfs(node):
    visited = set()
    stack = [node]

    while stack:
        current = stack.pop()
        if current not in visited:
            visited.add(current)
            print(current.value)
            stack.extend(reversed(current.children))

# Пример вызова
dfs(root)
```

**Принцип работы:**  
1. Начальной точкой служит корень дерева.  
2. Алгоритм использует стек для хранения обрабатываемых вершин.  
3. Пока стек не пуст, извлекается текущая вершина.  
4. Если вершина не была посещена:  
   - она добавляется в множество `visited`;  
   - выводится её значение;  
   - дочерние вершины добавляются в стек в обратном порядке (для корректной последовательности обхода).

**Оценка сложности:**  
Временная сложность алгоритма составляет $O(N + E)$, где:  
- $N$ — количество вершин;  
- $E$ — количество рёбер.  

Это обусловлено тем, что каждая вершина и каждое ребро обрабатываются ровно один раз.
