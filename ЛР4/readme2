Разбиваем задачу на подзадачи: проверяем первый символ строки, затем рекурсивно обрабатываем оставшуюся часть. Базовый случай — пустая строка или выход за границы.
Шаги алгоритма:
Базовый случай: если индекс вышел за пределы строки (index >= str.length()), возвращаем 0.
Проверка текущего символа:
Преобразуем символ к нижнему регистру.
Если символ — гласная (a, e, i, o, u), прибавляем 1.
Иначе прибавляем 0.
Рекурсивный вызов: вызываем функцию для следующего индекса (index + 1).
Суммируем результат проверки текущего символа и результат рекурсивного вызова.
public class VowelCounter {

    public static int countVowels(String str, int index) {
        // Базовый случай: вышли за пределы строки
        if (index >= str.length()) {
            return 0;
        }

        // Проверяем текущий символ
        char currentChar = Character.toLowerCase(str.charAt(index));
        int isVowel = (currentChar == 'a' || currentChar == 'e' || 
                        currentChar == 'i' || currentChar == 'o' || 
                        currentChar == 'u') ? 1 : 0;

        // Рекурсивный вызов для следующего индекса
        return isVowel + countVowels(str, index + 1);
    }

    // Упрощённый вызов (начинаем с индекса 0)
    public static int countVowels(String str) {
        return countVowels(str, 0);
    }

    // Пример использования
    public static void main(String[] args) {
        String text = "Hello World";
        int result = countVowels(text);
        System.out.println("Количество гласных: " + result); // Вывод: 3
    }
}



Вывод
Main.java:1: error: class VowelCounter is public, should be declared in a file named VowelCounter.java
public class VowelCounter 

Пояснения к коду:
Метод countVowels(String str, int index) — основная рекурсивная функция.
Метод countVowels(String str) — удобный интерфейс (начинает подсчёт с индекса 0).
Character.toLowerCase() — приводит символ к нижнему регистру для унификации проверки.
Проверка на гласную выполнена через логические операторы || (OR).

Временная сложность
Оценка: O(n), где n — длина строки.
Обоснование:
Количество вызовов: функция вызывается ровно n+1 раз:
n раз для каждого символа строки (индексы от 0 до n−1).
1 раз для базового случая (когда index == n).
Операции на каждом шаге:
Получение символа по индексу: O(1).
Приведение к нижнему регистру: O(1).
Проверка на гласную: O(1) (фиксированное число сравнений).
Рекурсивный вызов: O(1) (передача параметров).
Итого: на каждый из n+1 вызовов тратится O(1) времени. Суммарная сложность:
T(n)=O(1)⋅(n+1)=O(n).
Пространственная сложность
Оценка: O(n).
Обоснование:
Глубина рекурсии равна n+1 (по числу вызовов).
Каждый вызов добавляет фрейм в стек вызовов (содержит параметры и локальные переменные).
Размер каждого фрейма — константный (O(1)).
Итого: O(n) памяти для стека вызовов.
Важно:
В отличие от Python-версии со срезами, здесь нет копирования строк, поэтому пространственная сложность линейна (а не квадратична).
Оптимизация достигнута за счёт использования индекса вместо подстрок.



































