PYTHON
Разбиваем строку на части, обрабатываем первый символ, затем рекурсивно вызываем функцию для оставшейся подстроки. Базовый случай — пустая строка (возвращаем 0).
Шаги:
Базовый случай: если строка пуста (""), возвращаем 0.
Проверка первого символа:
Еслu первый символ — гласная (в любом регистре), прибавляем 1.
Иначе прибавляем 0.
Рекурсивный вызов: вызываем функцию для подстроки без первого символа (s[1:]).
Суммируем результат проверки первого символа и результат рекурсивного вызова.
 
def count_vowels(s):
    # Базовый случай: пустая строка
    if not s:
        return 0
    
    # Проверяем, является ли первый символ гласной
    first_char = s[0].lower()
    is_vowel = 1 if first_char in 'aeiou' else 0
    
    # Рекурсивный вызов для оставшейся части строки
    return is_vowel + count_vowels(s[1:])

вывод
print(count_vowels("Hello World"))  # Вывод: 3 (e, o, o)

Временная сложность
Оценка: O(n), где n — длина строки.

Почему?

Каждый рекурсивный вызов обрабатывает один символ строки (первый символ текущей подстроки).
После обработки первый символ «отсекается» (s[1:]), и функция вызывается для оставшейся части.
Всего будет ровно n вызовов (по одному на каждый символ), плюс один дополнительный вызов для пустой строки (базовый случай).
На каждом уровне рекурсии выполняется константное число операций (проверка символа, сложение), то есть O(1) на вызов.
Итого: T(n)=O(1)⋅(n+1)=O(n).


Примечание:

В Python срез s[1:] создаёт новую подстроку, что добавляет дополнительные затраты по памяти O(n) на каждый вызов (из-за копирования). Это делает общую пространственную сложность O(n2).
Для оптимизации можно использовать индексы вместо срезов (см. вариант ниже).

def count_vowels_optimized(s, index=0):
    # Базовый случай: вышли за пределы строки
    if index >= len(s):
        return 0
    
    # Проверяем текущий символ
    current_char = s[index].lower()
    is_vowel = 1 if current_char in 'aeiou' else 0
    
    # Рекурсивный вызов для следующего индекса
    return is_vowel + count_vowels_optimized(s, index + 1)

Преимущества:
Пространственная сложность: O(n) (только глубина рекурсии, без копирования строк).
Временная сложность: по-прежнему O(n).
























