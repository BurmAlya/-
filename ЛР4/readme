Вариант 6. Создайте рекурсивную функцию для подсчета количества гласных букв в строке.

PYTHON
Разбиваем строку на части, обрабатываем первый символ, затем рекурсивно вызываем функцию для оставшейся подстроки. Базовый случай — пустая строка (возвращаем 0).
Шаги:
Базовый случай: если строка пуста (""), возвращаем 0.
Проверка первого символа:
Еслu первый символ — гласная (в любом регистре), прибавляем 1.
Иначе прибавляем 0.
count_vowels("Привет"):
первый символ 'П' → не гласная → вызов count_vowels("ривет").
count_vowels("ривет"):
первый символ 'р' → не гласная → вызов count_vowels("ивет").
count_vowels("ивет"):
первый символ 'и' → гласная → 1+ вызов `count_vowels(“вет”)$.
count_vowels("вет"):
первый символ 'в' → не гласная → вызов count_vowels("ет").
count_vowels("ет"):
первый символ 'е' → гласная → 1+ вызов `count_vowels(“т”)$.
count_vowels("т"):
первый символ 'т' → не гласная → вызов count_vowels("").
count_vowels(""):
пустая строка → возвращаем 0.
Итог: 0+1+1=2.
Рекурсивный вызов: вызываем функцию для подстроки без первого символа (s[1:]).
Суммируем результат проверки первого символа и результат рекурсивного вызова.
Временная сложность
Оценка: O(n), где n — длина строки.
Почему?
Каждый рекурсивный вызов обрабатывает один символ строки (первый символ текущей подстроки).
После обработки первый символ «отсекается» (s[1:]), и функция вызывается для оставшейся части.
Всего будет ровно n вызовов (по одному на каждый символ), плюс один дополнительный вызов для пустой строки (базовый случай).
На каждом уровне рекурсии выполняется константное число операций (проверка символа, сложение), то есть O(1) на вызов.
Итого: T(n)=O(1)⋅(n+1)=O(n).




JAVA
Разбиваем задачу на подзадачи: проверяем первый символ строки, затем рекурсивно обрабатываем оставшуюся часть. Базовый случай — пустая строка или выход за границы.
Шаги алгоритма:
Базовый случай: если индекс вышел за пределы строки (index >= str.length()), возвращаем 0.
Проверка текущего символа:
Преобразуем символ к нижнему регистру.
Если символ — гласная (a, e, i, o, u), прибавляем 1.
Иначе прибавляем 0.
countVowels("Привет"):
преобразует строку в нижний регистр → "привет";
вызывает countVowelsRecursive("привет", 0).
countVowelsRecursive("привет", 0):
index = 0, символ 'п' → не гласная → вызов countVowelsRecursive("привет", 1).
countVowelsRecursive("привет", 1):
index = 1, символ 'р' → не гласная → вызов countVowelsRecursive("привет", 2).
countVowelsRecursive("привет", 2):
index = 2, символ 'и' → гласная → 1+ вызов countVowelsRecursive("привет", 3).
countVowelsRecursive("привет", 3):
index = 3, символ 'в' → не гласная → вызов countVowelsRecursive("привет", 4).
countVowelsRecursive("привет", 4):
index = 4, символ 'е' → гласная → 1+ вызов countVowelsRecursive("привет", 5).
countVowelsRecursive("привет", 5):
index = 5, символ 'т' → не гласная → вызов countVowelsRecursive("привет", 6).
countVowelsRecursive("привет", 6):
index = 6 ≥ length = 6 → базовое условие → возвращаем 0.
Итог: 0+1+1=2.
Рекурсивный вызов: вызываем функцию для следующего индекса (index + 1).
Суммируем результат проверки текущего символа и результат рекурсивного вызова.
Пояснения к коду:
Метод countVowels(String str, int index) — основная рекурсивная функция.
Метод countVowels(String str) — удобный интерфейс (начинает подсчёт с индекса 0).
Character.toLowerCase() — приводит символ к нижнему регистру для унификации проверки.
Проверка на гласную выполнена через логические операторы || (OR).
Временная сложность
Оценка: O(n), где n — длина строки.
Обоснование:
Количество вызовов: функция вызывается ровно n+1 раз:
n раз для каждого символа строки (индексы от 0 до n−1).
1 раз для базового случая (когда index == n).
Операции на каждом шаге:
Получение символа по индексу: O(1).
Приведение к нижнему регистру: O(1).
Проверка на гласную: O(1) (фиксированное число сравнений).
Рекурсивный вызов: O(1) (передача параметров).
Итого: на каждый из n+1 вызовов тратится O(1) времени. Суммарная сложность:
T(n)=O(1)⋅(n+1)=O(n).
Пространственная сложность
Оценка: O(n).
Обоснование:
Глубина рекурсии равна n+1 (по числу вызовов).
Каждый вызов добавляет фрейм в стек вызовов (содержит параметры и локальные переменные).
Размер каждого фрейма — константный (O(1)).
Итого: O(n) памяти для стека вызовов.
Важно:
В отличие от Python-версии со срезами, здесь нет копирования строк, поэтому пространственная сложность линейна (а не квадратична).
Оптимизация достигнута за счёт использования индекса вместо подстрок.




C++
Рекурсивно обрабатывать строку посимвольно, начиная с первого символа. На каждом шаге проверяем, является ли текущий символ гласной, затем вызываем функцию для оставшейся части строки.
Шаги алгоритма:
Базовый случай: если строка пуста (s.empty() или index >= s.length()), возвращаем 0.
Проверка текущего символа:
Преобразуем символ к нижнему регистру.
Если символ входит в набор гласных (a, e, i, o, u), прибавляем 1.
Иначе прибавляем 0.
Рекурсивный вызов: передаём подстроку без первого символа (s.substr(1)) или увеличиваем индекс на 1 (оптимизированный вариант).
Суммuруем результат проверки текущего символа и результат рекурсивного вызова.
Недостатки:
s.substr(1) создаёт новую строку, копируя n−1 символов → дорогостоящая операция.
Общая временная сложность: O(n2).
Пространственная сложность: O(n2) из‑за копирования строк.
Преимущества:
Нет копирования строк → эффективнее.
Простота вызова: countVowels("Hello") (используется параметр по умолчанию index = 0).
Временная сложность
Оценка:
Вариант 1 (с подстроками): O(n 2).
Вариaнт 2 (с индексом): O(n).
Обоснование:
Для варианта 1 (подстроки):
На первом вызове копируется n−1 символ.
На втором — n−2 символа.
На n-м вызове — 0 символов.
Суммарное число операций копирования:
(n−1)+(n−2)+…+1+0= 2n(n−1)=O(n2).
Проверка символа — O(1) на вызов, но доминирует копирование.
Для варианта 2 (индекс):
Количество вызовов: n+1 (от индекса 0 до n).
На каждом вызове:
Доступ к символу: O(1).
Приведение к нижнему регистру: O(1).
Проверка на гласную: O(1).
Итого: O(1)⋅(n+1)=O(n).
Пространственная сложность
Оценка:
Вариант 1: O(n2) — из‑за создания новых строк на каждом шаге.
Вариант 2: O(n) — глубина рекурсии n+1, каждый фрейм стека занимает O(1) памяти.
Почему?
В варианте 1 каждая подстрока требует O(n) памяти, и таких подстрок O(n).
В варианте 2 только стек вызовов занимает O(n) памяти (без дополнительных выделений).



ВОПРОС 7
Временная сложность задачи о N ферзях зависит от конкретного алгоритма решения,
но в большинстве практических реализаций (особенно при поиске всех решений методом перебора с возвратом) она имеет порядок O(N!) в худшем случае.
Почему O(N!)?
Суть задачи
Нужно разместить N ферзей на доске N×N так, чтобы ни один не бил другого. Каждый ферзь занимает ровно одну строку и один столбец, поэтому задача сводится к поиску перестановки [c1,c2,…,cN] столбцов, где c i
— столбец ферзя в строке i.
Перебор с возвратом (backtracking)
Типичный алгоритм:
Размещаем ферзя в первой строке в некотором столбце.
Для второй строки пробуем столбцы, не конфликтующие с первым ферзём.
Продолжаем рекурсивно, отступая, если тупик.
В худшем случае алгоритм исследует почти все возможные перестановки столбцов. Их число — N! (факториал).
Оценка сложности
На первом уровне рекурсии N вариантов.
На втором — до N−1 (один столбец занят).
На третьем — до N−2, и т. д.
Суммарное число узлов в дереве перебора пропорционально N!, поэтому временная сложность — O(N!).
Важные уточнения
O(N!) — это худший случай.
На практике многие ветки обрезаются рано (из‑за конфликтов по диагоналям), поэтому реальное время часто меньше.
Поиск одного решения может быть быстрее.
Некоторые эвристики (например, «минимальные конфликты») находят одно решение за O(N) или O(N 2) для больших N, но это не гарантирует нахождение всех решений.
Точная асимптотика зависит от реализации.
Оптимизации (битмаски, предварительные проверки) снижают константы, но не меняют асимптотический класс O(N!) для полного перебора.
Задача NP-полная?
Классическая задача о N ферзях (найти хотя бы одно решение) не является NP-полной — для неё существуют эффективные эвристики. Однако обобщения (например, с фиксированными ферзями на доске) могут быть NP-полными.
Итог
Для стандартного алгоритма перебора с возвратом, ищущего все решения, временная сложность — O(N!). Для поиска одного решения возможны алгоритмы со сложностью O(N) – O(N 2) при использовании эвристик
