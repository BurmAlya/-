сортировка выбором на с++
#include <iostream> // Подключаем библиотеку ввода-вывода

// Функция для печати элементов массива
void printArray(int arr[], int size) {
    for (int i = 0; i < size; ++i) {      // Проходим по каждому элементу массива
        std::cout << arr[i] << " ";       // Печать каждого элемента
    }
    std::cout << "\n";                    // Переход на новую строку после вывода всех элементов
}

// Основная функция сортировки выбором
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; ++i) {           // Внешний цикл проходит по массиву, начиная с первого элемента
        int minIndex = i;                       // Предполагаемый индекс минимального элемента изначально равен текущему индексу внешнего цикла
        
        // Внутренний цикл ищет минимальный элемент среди оставшихся
        for (int j = i + 1; j < n; ++j) {       // Начинаем искать минимум справа от текущего индекса
            if (arr[j] < arr[minIndex]) {      // Если найден меньший элемент, обновляем индекс минимума
                minIndex = j;                   // Обновление индекса минимального элемента
            }
        }
    
        // Меняем местами найденный минимальный элемент с текущим
        if (minIndex != i) {                     // Проверка необходима, чтобы избежать ненужных операций
            std::swap(arr[i], arr[minIndex]);   // Стандартная операция swap меняет элементы местами
        }
    }
}

// Главная функция программы
int main() {
    int arr[] = {64, 25, 12, 22, 11};          // Пример массива чисел
    int n = sizeof(arr)/sizeof(arr[0]);         // Определяем размер массива автоматически
    
    std::cout << "Исходный массив:\n";
    printArray(arr, n);                         // Печать исходного массива перед сортировкой
    
    selectionSort(arr, n);                      // Вызываем функцию сортировки
    
    std::cout << "Отсортированный массив:\n";
    printArray(arr, n);                         // Печать отсортированного массива
    
    return 0;                                   // Завершение программы успешно
}


#include <iostream> // Подключаем стандартную библиотеку ввода-вывода

// Вспомогательная функция для вывода массива на экран
void printArray(const int* array, const int size) {
    for (int i = 0; i < size; ++i) {          // Проходим по каждому элементу массива
        std::cout << array[i] << ' ';         // Выводим каждый элемент
    }
    std::cout << '\n';                        // Новый символ строки после полного вывода массива
}

Исходный массив:
64 25 12 22 11 
Отсортированный массив:
11 12 22 25 64 


[Execution Finished]







ЗАНОВО
сортировка пузерек
// Реализация алгоритма сортировки пузырьком
#include <iostream> // подключение стандартного ввода-вывода
void bubbleSort(int* array, const int size) {
    bool swapped;                             // Флаг для отслеживания наличия изменений
    do {
        swapped = false;                      // Первоначально считаем, что перестановок не было
        for (int i = 1; i < size; ++i) {      // Перебираем соседние пары элементов
            if (array[i - 1] > array[i]) {    // Если предыдущий элемент больше следующего
                std::swap(array[i - 1], array[i]); // Меняем их местами
                swapped = true;               // Установили флаг изменения
            }
        }
    } while(swapped);                          // Повторяем, пока происходят перестановки
}

// Точка входа в программу
int main() {
    int data[] = {64, 34, 25, 12, 22, 11, 90}; // Исходный массив для примера
    int length = sizeof(data) / sizeof(data[0]); // Автоматически получаем длину массива
    
    std::cout << "Исходный массив: ";
    printArray(data, length);                  // Показываем первоначальный порядок элементов
    
    bubbleSort(data, length);                  // Сортируем массив методом пузырьковой сортировки
    
    std::cout << "Отсортированный массив: ";
    printArray(data, length);                  // Выводим отсортированные элементы
    
    return 0;                                  // Программа завершилась нормально
}








сортировка вставками
#include <iostream> // подключаем стандартные средства ввода-вывода

// Вспомогательная функция для вывода массива на экран
void printArray(const int* array, const int size) {
    for (int i = 0; i < size; ++i) {      // пробегаемся по всему массиву
        std::cout << array[i] << ' ';      // выводим каждый элемент массива
    }
    std::cout << '\n';                    // переход на новую строку после вывода всего массива
}

// Основная функция сортировки вставками
void insertionSort(int* array, const int size) {
    for (int i = 1; i < size; ++i) {      // начинаем обработку со второго элемента (индекс 1)
        int key = array[i];                // запоминаем текущий обрабатываемый элемент
        int j = i - 1;                     // устанавливаем указатель на предыдущий элемент
        
        // сдвигаем предыдущие элементы вправо, если они больше текущего ключа
        while(j >= 0 && array[j] > key) {
            array[j+1] = array[j];         // сдвигаем больший элемент направо
            --j;                           // уменьшаем индекс предыдущего элемента
        }
        
        array[j+1] = key;                  // помещаем ключ в правильное место
    }
}

// точка входа в программу
int main() {
    int numbers[] = {12, 11, 13, 5, 6};   // создадим небольшой тестовый массив
    int len = sizeof(numbers) / sizeof(numbers[0]); // вычислим его длину
    
    std::cout << "Исходный массив: ";
    printArray(numbers, len);              // выведем исходный массив
    
    insertionSort(numbers, len);           // применим сортировку вставками
    
    std::cout << "Отсортированный массив: ";
    printArray(numbers, len);              // выведем отсортированный массив
    
    return 0;                              // успешное завершение программы
}

Исходный массив: 12 11 13 5 6 
Отсортированный массив: 5 6 11 12 13 


[Execution Finished]








сортировка слиянием
#include <iostream> // подключение стандартного ввода-вывода
using namespace std; // использование пространства имен std

// Вспомогательная функция для объединения двух отсортированных частей массива
void merge(int arr[], int left, int mid, int right) {
    int i, j, k;                                    // счётчики для левого, правого диапазонов и результирующего массива
    int n1 = mid - left + 1;                        // размер левой части
    int n2 = right - mid;                           // размер правой части
    
    // создание временных массивов для хранения отсортированных частей
    int L[n1], R[n2];
    
    // копируем левую половину массива в временный массив L[]
    for(i = 0; i < n1; i++) {
        L[i] = arr[left + i];
    }
    
    // копируем правую половину массива в временный массив R[]
    for(j = 0; j < n2; j++) {
        R[j] = arr[mid + 1 + j];
    }
    
    // сливаем две отсортированные части в основной массив
    i = 0;                                          // индекс начала левой части
    j = 0;                                          // индекс начала правой части
    k = left;                                       // индекс места вставки в основном массиве
    
    while(i < n1 && j < n2) {                      // пока не закончились элементы обеих частей
        if(L[i] <= R[j]) {                          // сравниваем первые элементы обоих массивов
            arr[k++] = L[i++];                      // вставляем меньший элемент из левой части
        } else {
            arr[k++] = R[j++];                      // иначе вставляем элемент из правой части
        }
    }
    
    // оставшиеся элементы левой части, если правая закончилась раньше
    while(i < n1) {
        arr[k++] = L[i++];
    }
    
    // оставшиеся элементы правой части, если левая закончилась раньше
    while(j < n2) {
        arr[k++] = R[j++];
    }
}

// Рекурсивная функция сортировки слиянием
void mergeSort(int arr[], int left, int right) {
    if(left < right) {                              // если интервал содержит хотя бы два элемента
        int mid = left + (right - left) / 2;        // нахождение середины интервала
        
        // рекурсивно сортируем левую половину
        mergeSort(arr, left, mid);
        
        // рекурсивно сортируем правую половину
        mergeSort(arr, mid + 1, right);
        
        // объединяем отсортированные половины
        merge(arr, left, mid, right);
    }
}

// Функция для вывода массива на экран
void printArray(int A[], int size) {
    for(int i = 0; i < size; i++)
        cout << A[i] << " ";
    cout << endl;
}

// главная функция
int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};    // тестовый массив
    int arr_size = sizeof(arr) / sizeof(arr[0]); // вычисляем длину массива
    
    cout << "Исходный массив: \n";
    printArray(arr, arr_size);              // выводим исходный массив
    
    mergeSort(arr, 0, arr_size - 1);       // вызываем сортировку слиянием
    
    cout << "Отсортированный массив: \n";
    printArray(arr, arr_size);              // выводим отсортированный массив
    
    return 0;
}

Исходный массив: 
12 11 13 5 6 7 
Отсортированный массив: 
5 6 7 11 12 13 


[Execution Finished]
















пирамидальной сортировки (Heap Sort)
#include <iostream>
#include <vector>

// Функциональность для преобразования дерева в кучеобразную форму
void heapify(std::vector<int>& arr, int n, int root) {
    int largest = root;      // Корень поддерева
    int leftChild = 2 * root + 1;  // Левый ребенок узла
    int rightChild = 2 * root + 2; // Правый ребенок узла

    // Если левый дочерний узел существует и больше корня
    if (leftChild < n && arr[leftChild] > arr[largest])
        largest = leftChild;

    // Если правый дочерний узел существует и больше корня
    if (rightChild < n && arr[rightChild] > arr[largest])
        largest = rightChild;

    // Если максимальный элемент не корень, меняем местами и рекурсивно восстанавливаем кучу
    if (largest != root) {
        std::swap(arr[root], arr[largest]);
        heapify(arr, n, largest);  // Рекурсивно вызываем heapify для нового поддерева
    }
}

// Основная функция пирамидальной сортировки
void heapSort(std::vector<int>& arr) {
    int n = arr.size();

    // Строим max-кучу из входного массива
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // Один за другим извлекаем элементы из кучи
    for (int i = n - 1; i > 0; i--) {
        // Перемещаем текущий корневой элемент (максимальный) в конец массива
        std::swap(arr[0], arr[i]);

        // Восстанавливаем max-кучу заново
        heapify(arr, i, 0);
    }
}

// Вспомогательная функция для вывода массива
void printArray(const std::vector<int>& arr) {
    for (auto num : arr)
        std::cout << num << " ";
    std::cout << std::endl;
}

// Главная функция программы
int main() {
    std::vector<int> arr = {12, 11, 13, 5, 6, 7};
    std::cout << "Исходный массив: ";
    printArray(arr);

    heapSort(arr);

    std::cout << "Отсортированный массив: ";
    printArray(arr);

    return 0;
}

Исходный массив: 12 11 13 5 6 7 
Отсортированный массив: 5 6 7 11 12 13 


[Execution Finished]






ЗАНОВО
последовательный поиск
#include <iostream>
#include <vector>

// Линейный поиск элемента в массиве
int sequentialSearch(const std::vector<int>& arr, int target) {
    // Просматриваем массив от начала до конца
    for (size_t i = 0; i < arr.size(); ++i) {
        // Если текущий элемент совпадает с целевым, возвращаем его индекс
        if (arr[i] == target) {
            return static_cast<int>(i); // Приводим тип к int для совместимости
        }
    }
    // Если элемент не найден, возвращаем специальный индикатор (-1)
    return -1;
}

// Функция для тестирования поиска
int main() {
    std::vector<int> data = {10, 25, 30, 45, 50, 60, 75};
    int searchKey = 45; // Значение, которое будем искать

    // Осуществляем поиск
    int result = sequentialSearch(data, searchKey);

    // Выводим результат
    if (result != -1) {
        std::cout << "Элемент " << searchKey << " найден на позиции " << result << "." << std::endl;
    } else {
        std::cout << "Элемент " << searchKey << " не найден." << std::endl;
    }

    return 0;
}








ЗАНОВО
Интерполирующий поиск
#include <iostream>
using namespace std;

// Функция для интерполирующего поиска
int interpolationSearch(int arr[], int n, int x) {
    int low = 0;                   // Нижняя граница поиска
    int high = n - 1;              // Верхняя граница поиска

    // Продолжаем поиск, пока нижняя граница не превышает верхнюю
    while ((low <= high) && (x >= arr[low]) && (x <= arr[high])) {
        // Предположительная позиция элемента рассчитывается следующим образом:
        // Идея заключается в линейной интерполяции, учитывающей диапазон значений и расстояние между границами
        int pos = low + (((double)(high - low) / (arr[high] - arr[low])) * (x - arr[low]));

        // Если элемент найден на рассчитанной позиции
        if (arr[pos] == x) {
            return pos;                // Возвращаем индекс найденного элемента
        }

        // Если целевой элемент меньше, сужаем диапазон сверху
        if (arr[pos] < x) {
            low = pos + 1;             // Переносим нижнюю границу вверх
        }
        // Если целевой элемент больше, сужаем диапазон снизу
        else {
            high = pos - 1;            // Переносим верхнюю границу вниз
        }
    }

    // Если элемент не найден
    return -1;
}

// Основная программа для тестирования поиска
int main() {
    int sortedArray[] = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23};
    int size = sizeof(sortedArray)/sizeof(sortedArray[0]);
    int searchElement = 18;

    // Выполняем поиск
    int index = interpolationSearch(sortedArray, size, searchElement);

    // Вывод результата
    if(index != -1){
        cout << "Элемент " << searchElement << " найден на индексе " << index << endl;
    } else{
        cout << "Элемент не найден." << endl;
    }

    return 0;
}







