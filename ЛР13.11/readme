ВАРИАНТ 20
ПУНКТ I
Вариант 20. Генетический алгоритм для задачи коммивояжера
Задача: реализовать генетический алгоритм для решения задачи коммивояжера.
Требования:
- Представление: перестановка городов
- Кроссовер: Order Crossover (OX)
- Мутация: случайный swap двух городов
- Размер популяции: 30
- Количество поколений: 100
- Вывести лучший найденный маршрут и его стоимость
Входные данные:
Матрица расстояний для 10 городов
ПУНКТ II
Пояснение каждого шага:
DISTANCE_MATRIX — квадратная матрица, где элемент [i][j] — расстояние от города i до города j.
N_CITIES — количество городов (10).
Алгоритм будет работать с популяцией из 30 особей в течение 100 поколений.
Инициализация данных
Создаётся случайная симметричная матрица расстояний 10 × 10.
Диагональ обнуляется (расстояние от города до себя = 0).
Расчёт длины маршрута
Функция calculate_route_length проходит по всем городам в перестановке и суммирует расстояния, включая возврат в стартовый город.
Создание особи
create_individual генерирует случайную перестановку чисел от 0 до 9 (номера городов).
Order Crossover (OX)
Выбирается случайный сегмент из первого родителя.
Создание особи (маршрута)
python
def create_individual():
    route = list(range(N_CITIES))  # [0, 1, 2, ..., 9]
    random.shuffle(route)           # перемешиваем случайно
    return route
Что делает:
Создаёт случайный маршрут — перестановку всех городов.
Этот сегмент копируется в потомка.
Остальные города добавляются из второго родителя в порядке их появления, пропуская уже вставленные.
Мутация (swap)
python
def mutate(individual):
    if random.random() < MUTATION_RATE:  # 10% шанс
        i, j = random.sample(range(N_CITIES), 2)  # два случайных индекса
        individual[i], individual[j] = individual[j], individual[i]  # меняем местами
    return individual
Что делает: с вероятностью 10% меняет местами два случайных города в маршруте.
С вероятностью 10 % случайно выбираются два города и меняются местами.
Турнирный отбор
Из 3 случайно выбранных особей выбирается та, у которой наибольший fitness (1 / длина маршрута).
Основной цикл ГА
Для каждого поколения:
Вычисляется fitness всех особей.
Сохраняется лучший маршрут.
Формируется новое поколение через отбор, кроссовер и мутацию.
Вывод результата
Печатается лучший маршрут и его длина.
route — список индексов городов, например [0, 2, 1, 3, ..., 9].
Проходим по всем городам в маршруте:
from_city — текущий город.
to_city — следующий город (для последнего берём первый, благодаря % len(route)).
ПУНКТ III
Временная сложность
Обозначим:
n — число городов (10),
P — размер популяции (30),
G — число поколений (100).
Инициализация популяции: O(P⋅n)
Создание P перестановок длиной n.
Расчёт fitness за поколение: O(P⋅n)
Для каждой особи проходим по n рёбрам маршрута.
Отбор родителей: O(P⋅T), где T — размер турнира (3)
Для каждой новой особи проводим турнир из T особей.
Кроссовер (OX): O(n2) на одну пару родителей
Копирование сегмента — O(n).
Проверка if city not in child — O(n) на каждую итерацию, всего O(n 2).
Мутация: O(1) на особь
Обмен двух элементов — константное время.
Общее за поколение:
O(P⋅n)+O(P⋅T)+O(P⋅n2)+O
ПУНКТ IV
Анализ временной сложности
Обозначим:
n — число городов (n=10),
P — размер популяции (P=30),
G — число поколений (G=100).
Сложность одного поколения
Расчёт стоимости всех маршрутов:
Для одного маршрута: O(n) (проход по n городам).
Для всей популяции: O(P⋅n).
Отбор родителей (на одну особь):
Турнир из 3 особей: O(1) на отбор (поиск минимума в 3 элементах).
На поколение: O(P) отборов → O(P).
Кроссовер (на одну особь):
Копирование сегмента: O(n).
Заполнение оставшихся позиций: O(n) (проверка вхождения в список).
ПУНКТ V
Алгоритм кода последовательно:
задаёт данные и параметры;
определяет операции эволюции;
инициализирует популяцию;
итеративно улучшает её;
выдаёт оптимальный маршрут.
ШАГИ АЛГОРИТМА
Шаг 1. Подготовка входных данных и параметров
Что делается:
Задаётся матрица расстояний между городами (DISTANCE_MATRIX) — симметричная матрица размера 10×10.
Определяются гиперпараметры алгоритма:
размер популяции: POPULATION_SIZE=30;
число поколений: NUM_GENERATIONS=100;
вероятность мутации: MUTATION_RATE=0,1.
Фиксируется число городов: N_CITIES=10.
Зачем:
Задать условия задачи и настройки алгоритма.
Шаг 2. Определение вспомогательных функций
Что делается:
Реализуются функции для базовых операций:
calculate_route_cost(route) — вычисляет полную длину маршрута (с возвратом в начальный город).
create_individual() — генерирует случайный маршрут (перестановку городов).
create_population() — создаёт начальную популяцию из 30 случайных маршрутов.
order_crossover(parent1, parent2) — выполняет кроссовер (OX) для двух родителей.
mutate(individual) — применяет мутацию (обмен двух городов) с вероятностью 0,1.
select_parents(population, costs) — отбирает родителей турнирным методом (турнир из 3 особей).
Зачем:
Обеспечить модульность и повторное использование кода для эволюционных операций.
Шаг 3. Инициализация популяции
Что делается:
Вызывается create_population(), чтобы получить 30 случайных маршрутов.
Инициализируются переменные для хранения лучшего решения:
best_route = None;
best_cost = \infty.
Зачем:
Начать поиск с разнообразного набора потенциальных решений.
Шаг 4. Эволюционный цикл (по поколениям)
Что делается:
Для каждого поколения (100 итераций):
Вычисляются стоимости всех маршрутов в популяции (costs).
Обновляется лучшее найденное решение, если текущее поколение дало улучшение
Формируется новое поколение:
Отбираются два родителя турнирным методом.
Применяется кроссовер (OX) для получения потомка.
Потомк подвергается мутации (с вероятностью 0,1).
Потомок добавляется в новую популяцию.
Старая популяция заменяется новой.
Зачем:
Постепенно улучшать качество решений за счёт отбора, кроссовера и мутации.
Шаг 5. Вывод результата
Что делается:
После завершения цикла:
Печатается лучший найденный маршрут (последовательность городов).
Выводится его стоимость (общая длина).
Зачем:
Предоставить итоговое решение задачи коммивояжёра.
