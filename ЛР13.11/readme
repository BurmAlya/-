ВАРИАНТ 20
ПУНКТ I
Вариант 20. Генетический алгоритм для задачи коммивояжера
Задача: реализовать генетический алгоритм для решения задачи коммивояжера.
Требования:
- Представление: перестановка городов
- Кроссовер: Order Crossover (OX)
- Мутация: случайный swap двух городов
- Размер популяции: 30
- Количество поколений: 100
- Вывести лучший найденный маршрут и его стоимость
Входные данные:
Матрица расстояний для 10 городов
ПУНКТ II
Пояснение каждого шага:
DISTANCE_MATRIX — квадратная матрица, где элемент [i][j] — расстояние от города i до города j.
N_CITIES — количество городов (10).
Алгоритм будет работать с популяцией из 30 особей в течение 100 поколений.
Инициализация данных
Создаётся случайная симметричная матрица расстояний 10 × 10.
Диагональ обнуляется (расстояние от города до себя = 0).
Расчёт длины маршрута
Функция calculate_route_length проходит по всем городам в перестановке и суммирует расстояния, включая возврат в стартовый город.
Создание особи
create_individual генерирует случайную перестановку чисел от 0 до 9 (номера городов).
Order Crossover (OX)
Выбирается случайный сегмент из первого родителя.
Создание особи (маршрута)
python
def create_individual():
    route = list(range(N_CITIES))  # [0, 1, 2, ..., 9]
    random.shuffle(route)           # перемешиваем случайно
    return route
Что делает:
Создаёт случайный маршрут — перестановку всех городов.
Этот сегмент копируется в потомка.
Остальные города добавляются из второго родителя в порядке их появления, пропуская уже вставленные.
Мутация (swap)
python
def mutate(individual):
    if random.random() < MUTATION_RATE:  # 10% шанс
        i, j = random.sample(range(N_CITIES), 2)  # два случайных индекса
        individual[i], individual[j] = individual[j], individual[i]  # меняем местами
    return individual
Что делает: с вероятностью 10% меняет местами два случайных города в маршруте.
С вероятностью 10 % случайно выбираются два города и меняются местами.
Турнирный отбор
Из 3 случайно выбранных особей выбирается та, у которой наибольший fitness (1 / длина маршрута).
Основной цикл ГА
Для каждого поколения:
Вычисляется fitness всех особей.
Сохраняется лучший маршрут.
Формируется новое поколение через отбор, кроссовер и мутацию.
Вывод результата
Печатается лучший маршрут и его длина.
Расчёт стоимости маршрута
route — список индексов городов, например [0, 2, 1, 3, ..., 9].
Проходим по всем городам в маршруте:
from_city — текущий город.
to_city — следующий город (для последнего берём первый, благодаря % len(route)).
Создание популяции
def create_population():
    return [create_individual() for _ in range(POPULATION_SIZE)]
Результат: список из 30 случайных маршрутов.
 Кроссовер (Order Crossover, OX)
python
def order_crossover(parent1, parent2):
    size = len(parent1)
    start, end = sorted(random.sample(range(size), 2))  # случайный сегмент
    
    child = [-1] * size  # потомк с "дырами" (-1)
    child[start:end] = parent1[start:end]  # копируем сегмент из parent1
    
    pointer = end
    for city in parent2:
        if city not in child:  # если города ещё нет в потомке
            if pointer >= size:
                pointer = 0  # переходим в начало (кольцевой буфер)
            child[pointer] = city
            pointer += 1
    return child
Пошагово:
Выбираем случайный сегмент [start:end] из parent1.
Копируем этот сегмент в потомка.
Остальные города берём из parent2 в порядке их появления, пропуская уже добавленные.
Заполняем потомка по кругу (если вышли за границы — начинаем с начала).
Отбор родителей (турнирный)
python
def select_parents(population, costs):
    tournament_size = 3
    tournament = random.sample(list(zip(population, costs)), tournament_size)
    winner = min(tournament, key=lambda x: x[1])  # выбираем по минимальной стоимости
    return winner[0]  # возвращаем маршрут (individual)
Как работает:
Берём 3 случайных особи из популяции.
Среди них выбираем ту, у которой cost (стоимость маршрута) минимальна.
Возвращаем этот маршрут как родителя.
Пошагово для каждого поколения:
Рассчитываем стоимости всех 30 маршрутов.
Находим лучший маршрут в текущем поколении и обновляем глобальный рекорд.
Создаём новую популяцию:
Отбираем 2 родителя (турнирным методом)
Применяем кроссовер → получаем потомка
Применяем мутацию → модифицируем потомка.
Добавляем в новую популяцию.
Заменяем старую популяцию на новую.
ПУНКТ III
Временная сложность
Обозначим:
n — число городов (10),
P — размер популяции (30),
G — число поколений (100).
Инициализация популяции: O(P⋅n)
Создание P перестановок длиной n.
Расчёт fitness за поколение: O(P⋅n)
Для каждой особи проходим по n рёбрам маршрута.
Отбор родителей: O(P⋅T), где T — размер турнира (3)
Для каждой новой особи проводим турнир из T особей.
Кроссовер (OX): O(n2) на одну пару родителей
Копирование сегмента — O(n).
Проверка if city not in child — O(n) на каждую итерацию, всего O(n 2).
Мутация: O(1) на особь
Обмен двух элементов — константное время.
Общее за поколение:
O(P⋅n)+O(P⋅T)+O(P⋅n2)+O
ПУНКТ IV
Анализ временной сложности
Обозначим:
n — число городов (n=10),
P — размер популяции (P=30),
G — число поколений (G=100).
Сложность одного поколения
Расчёт стоимости всех маршрутов:
Для одного маршрута: O(n) (проход по n городам).
Для всей популяции: O(P⋅n).
Отбор родителей (на одну особь):
Турнир из 3 особей: O(1) на отбор (поиск минимума в 3 элементах).
На поколение: O(P) отборов → O(P).
Кроссовер (на одну особь):
Копирование сегмента: O(n).
Заполнение оставшихся позиций: O(n) (проверка вхождения в список).
ПУНКТ V
Алгоритм кода последовательно:
задаёт данные и параметры;
определяет операции эволюции;
инициализирует популяцию;
итеративно улучшает её;
выдаёт оптимальный маршрут.
ШАГИ АЛГОРИТМА
Шаг 1. Подготовка входных данных и параметров
Что делается:
Задаётся матрица расстояний между городами (DISTANCE_MATRIX) — симметричная матрица размера 10×10.
Определяются гиперпараметры алгоритма:
размер популяции: POPULATION_SIZE=30;
число поколений: NUM_GENERATIONS=100;
вероятность мутации: MUTATION_RATE=0,1.
Фиксируется число городов: N_CITIES=10.
Зачем:
Задать условия задачи и настройки алгоритма.
Шаг 2. Определение вспомогательных функций
Что делается:
Реализуются функции для базовых операций:
calculate_route_cost(route) — вычисляет полную длину маршрута (с возвратом в начальный город).
create_individual() — генерирует случайный маршрут (перестановку городов).
create_population() — создаёт начальную популяцию из 30 случайных маршрутов.
order_crossover(parent1, parent2) — выполняет кроссовер (OX) для двух родителей.
mutate(individual) — применяет мутацию (обмен двух городов) с вероятностью 0,1.
select_parents(population, costs) — отбирает родителей турнирным методом (турнир из 3 особей).
Зачем:
Обеспечить модульность и повторное использование кода для эволюционных операций.
Шаг 3. Инициализация популяции
Что делается:
Вызывается create_population(), чтобы получить 30 случайных маршрутов.
Инициализируются переменные для хранения лучшего решения:
best_route = None;
best_cost = \infty.
Зачем:
Начать поиск с разнообразного набора потенциальных решений.
Шаг 4. Эволюционный цикл (по поколениям)
Что делается:
Для каждого поколения (100 итераций):
Вычисляются стоимости всех маршрутов в популяции (costs).
Обновляется лучшее найденное решение, если текущее поколение дало улучшение
Формируется новое поколение:
Отбираются два родителя турнирным методом.
Применяется кроссовер (OX) для получения потомка.
Потомк подвергается мутации (с вероятностью 0,1).
Потомок добавляется в новую популяцию.
Старая популяция заменяется новой.
Зачем:
Постепенно улучшать качество решений за счёт отбора, кроссовера и мутации.
Шаг 5. Вывод результата
Что делается:
После завершения цикла:
Печатается лучший найденный маршрут (последовательность городов).
Выводится его стоимость (общая длина).
Зачем:
Предоставить итоговое решение задачи коммивояжёра.
ОТВЕТ НА КОНТРОЛЬНЫЙ ВОПРОС
20. Применение в практике
Приведите 5 примеров реальных приложений, где используются приближенные или
эвристические алгоритмы.
1. Логистика и маршрутизация 
   Задача: построение оптимальных маршрутов для доставки (VRP — Vehicle Routing Problem).  
   Почему эвристика: точное решение для сотен точек нереально из‑за экспоненциальной сложности.  
   Алгоритмы:  
     Genetic Algorithms* (генетические алгоритмы) — эволюционный подбор маршрутов;  
     Simulated Annealing* (имитация отжига) — поиск баланса между качеством и временем расчёта;  
     Ant Colony Optimization* (оптимизация по принципу муравьиной колонии) — имитация поведения муравьёв для нахождения кратчайших путей.  
    Примеры:  
      сервисы доставки (Яндекс Доставка, СДЭК);  
     планирование маршрутов мусоровозов, школьных автобусов.

2. Планирование производства и цепочек поставок 
   Задача: распределение ресурсов, графиков смен, запасов на складах.  
   Почему эвристика: множество ограничений (сроки, мощности, стоимость) делают точное решение нецелесообразным.  
   Алгоритмы:  
     Tabu Search (табу‑поиск) — избегание зацикливания на локальных оптимумах;  
     GRASP (Greedy Randomized Adaptive Search Procedure) — жадно‑случайный поиск с локальными улучшениями.  
   Примеры:  
     системы ERP (SAP, Oracle) для планирования производства;  
     управление запасами в ритейле (Walmart, Amazon).

3. Телекоммуникации и сети 
  Задача: размещение базовых станций, оптимизация трафика, маршрутизация в сетях 5G/6G.  
  Почему эвристика: динамичность нагрузки и топологии требует быстрых приближённых решений.  
  Алгоритмы:  
     Particle Swarm Optimization* (метод роя частиц) — поиск оптимальных позиций станций;  
    Local Search с метаэвристиками — балансировка нагрузки между узлами.  
   Примеры:  
      планирование сетей мобильных операторов (МТС, Билайн);  
     оптимизация CDN (Content Delivery Networks) для стриминга видео.

4.Биоинформатика и геномика  
   Задача: сборка геномов из фрагментов (sequence assembly), выравнивание последовательностей.  
   Почему эвристика: миллиарды пар оснований делают точные методы неприменимыми.  
  Алгоритмы:  
     Greedy algorithms (жадные алгоритмы) — поэтапное склеивание фрагментов;  
     Simulated Annealing— оптимизация выравнивания с учётом мутаций.  
  Примеры:  
      программы сборки геномов (SPAdes, Velvet);  
      анализ вариаций ДНК в медицинских исследованиях.

5. Машинное обучение и оптимизация гиперпараметров**  
   Задача: подбор оптимальных гиперпараметров модели (скорость обучения, число слоёв нейронной сети).  
   Почему эвристика: перебор всех комбинаций невозможен из‑за времени обучения моделей.  
   Алгоритмы:  
     Bayesian Optimization (байесовская оптимизация) — моделирование функции потерь и поиск оптимума;  
     Random Search — случайный отбор комбинаций с лучшей эффективностью, чем полный перебор;  
     Evolutionary Strategies — эволюционный подбор конфигураций.  
   Примеры:  
      автоматизированная настройка моделей в AutoML (Google AutoML, H2O.ai);  
      оптимизация нейросетей для компьютерного зрения (YOLO, ResNet).

Общий принцип: во всех этих случаях эвристики дают «достаточно хорошее» решение за приемлемое время, тогда как точные методы либо невозможны, либо требуют неприемлемых вычислительных ресурсов.
