Вариант 20. Генетический алгоритм для задачи коммивояжера
Задача: реализовать генетический алгоритм для решения задачи коммивояжера.
Требования:
- Представление: перестановка городов
- Кроссовер: Order Crossover (OX)
- Мутация: случайный swap двух городов
- Размер популяции: 30
- Количество поколений: 100
- Вывести лучший найденный маршрут и его стоимость
Входные данные:
Матрица расстояний для 10 городов

КОД
import random
import numpy as np

# --- 1. Входные данные: матрица расстояний для 10 городов ---
# Симметричная матрица (пример)
DISTANCE_MATRIX = np.array([
    [0,  2,  9,  10, 7,  3,  8,  5,  6,  4],
    [2,  0,  6,  4,  8,  9,  7,  3,  1,  5],
    [9,  6,  0,  8,  7,  6,  4,  5,  3,  2],
    [10, 4,  8,  0,  5,  7,  6,  9,  8,  1],
    [7,  8,  7,  5,  0,  4,  3,  6,  5,  9],
    [3,  9,  6,  7,  4,  0,  2,  8,  7,  6],
    [8,  7,  4,  6,  3,  2,  0,  9,  8,  5],
    [5,  3,  5,  9,  6,  8,  9,  0,  4,  7],
    [6,  1,  3,  8,  5,  7,  8,  4,  0,  2],
    [4,  5,  2,  1,  9,  6,  5,  7,  2,  0]
])

N_CITIES = DISTANCE_MATRIX.shape[0]  # 10 городов

# --- 2. Параметры генетического алгоритма ---
POPULATION_SIZE = 30
NUM_GENERATIONS = 100
MUTATION_RATE = 0.1  # 10% вероятность мутации

# --- 3. Вспомогательные функции ---

def calculate_route_cost(route):
    """
    Вычисляет стоимость маршрута (сумму расстояний).
    route: список индексов городов, например [0, 2, 1, ..., 9]
    """
    cost = 0
    for i in range(len(route)):
        from_city = route[i]
        to_city = route[(i + 1) % len(route)]  # возврат в начальный город
        cost += DISTANCE_MATRIX[from_city, to_city]
    return cost

def create_individual():
    """Создаёт случайный маршрут (перестановку городов)."""
    route = list(range(N_CITIES))
    random.shuffle(route)
    return route

def create_population():
    """Создаёт начальную популяцию."""
    return [create_individual() for _ in range(POPULATION_SIZE)]

def order_crossover(parent1, parent2):
    """
    Order Crossover (OX): создаёт потомка на основе порядка элементов у родителей.
    """
    size = len(parent1)
    # Выбираем случайный сегмент
    start, end = sorted(random.sample(range(size), 2))
    
    # Создаём потомка, копируя сегмент из parent1
    child = [-1] * size
    child[start:end] = parent1[start:end]
    
    # Заполняем оставшиеся позиции элементами из parent2 в порядке их появления
    pointer = end
    for city in parent2:
        if city not in child:
            if pointer >= size:
                pointer = 0
            child[pointer] = city
            pointer += 1
    
    return child

def mutate(individual):
    """
    Мутация: случайный swap двух городов.
    """
    if random.random() < MUTATION_RATE:
        i, j = random.sample(range(N_CITIES), 2)
        individual[i], individual[j] = individual[j], individual[i]
    return individual

def select_parents(population, costs):
    """
    Отбор родителей: турнирный отбор (размер турнира = 3).
    Возвращает двух родителей.
    """
    tournament_size = 3
    tournament = random.sample(list(zip(population, costs)), tournament_size)
    winner = min(tournament, key=lambda x: x[1])  # минимальный cost
    return winner[0]

# --- 4. Основной цикл генетического алгоритма ---

def genetic_algorithm():
    # Инициализация популяции
    population = create_population()
    
    best_route = None
    best_cost = float('inf')
    
    for generation in range(NUM_GENERATIONS):
        # Вычисляем стоимость каждого маршрута
        costs = [calculate_route_cost(individual) for individual in population]
        
        # Обновляем лучший найденный маршрут
        min_cost = min(costs)
        if min_cost < best_cost:
            best_cost = min_cost
            best_route = population[costs.index(min_cost)]
        
        # Создаём новое поколение
        new_population = []
        for _ in range(POPULATION_SIZE):
            # Отбираем двух родителей
            parent1 = select_parents(population, costs)
            parent2 = select_parents(population, costs)
            
            # Кроссовер
            child = order_crossover(parent1, parent2)
            
            # Мутация
            child = mutate(child)
            
            new_population.append(child)
        
        population = new_population  # Переходим к новому поколению
    
    return best_route, best_cost

# --- 5. Запуск и вывод результата ---

if __name__ == "__main__":
    best_route, best_cost = genetic_algorithm()
    
    print("Лучший найденный маршрут:")
    print(" -> ".join(map(str, best_route)))
    print(f"Стоимость маршрута: {best_cost}")

ВЫВОД
Лучший найденный маршрут:
5 -> 6 -> 2 -> 9 -> 3 -> 4 -> 7 -> 8 -> 1 -> 0
Стоимость маршрута: 30
[Execution Finished]
