1.Блочная (корзинная) сортировка

Код

def bucket_sort(arr, num_buckets=10):
    """
    Блочная (корзинная) сортировка.
    
    Параметры:
        arr (list): список чисел для сортировки (float или int).
        num_buckets (int): количество корзин (по умолчанию 10).
    
    Возвращает:
        list: отсортированный список.
    """
    if len(arr) == 0:
        return arr

    # Находим минимум и максимум для равномерного распределения по корзинам
    min_val = min(arr)
    max_val = max(arr)

    # Если все элементы одинаковы, возвращаем исходный массив
    if min_val == max_val:
        return arr

    # Создаём корзины (пустые списки)
    buckets = [[] for _ in range(num_buckets)]

    # Распределяем элементы по корзинам
    for num in arr:
        # Вычисляем индекс корзины
        # Нормализуем значение к диапазону [0, 1), затем умножаем на num_buckets
        index = int((num - min_val) / (max_val - min_val) * (num_buckets - 1))
        buckets[index].append(num)

    # Сортируем каждую корзину (алгоритмом вставки)
    for bucket in buckets:
        insertion_sort(bucket)

    # Объединяем корзины в один отсортированный массив
    sorted_arr = []
    for bucket in buckets:
        sorted_arr.extend(bucket)

    return sorted_arr



def insertion_sort(arr):
    """
    Сортировка вставками для отдельной корзины.
    
    Параметры:
        arr (list): список для сортировки.
    """
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key



# Пример использования
if __name__ == "__main__":
    # Тестовый массив
    data = [0.89, 0.56, 0.65, 0.12, 0.34, 0.98, 0.23, 0.76, 0.45, 0.01]
    print("Исходный массив:", data)

    sorted_data = bucket_sort(data, num_buckets=5)
    print("Отсортированный массив:", sorted_data)

Результат работы алгоритма
               
Исходный массив: [0.89, 0.56, 0.65, 0.12, 0.34, 0.98, 0.23, 0.76, 0.45, 0.01]
Отсортированный массив: [0.01, 0.12, 0.23, 0.34, 0.45, 0.56, 0.65, 0.76, 0.89, 0.98]





2.Блинная сортировка

Код

def pancake_sort(arr):
    """
    Сортировка блинным методом (pancake sort).
    
    Параметры:
        arr (list): список чисел для сортировки
    
    Возвращает:
        list: отсортированный список по возрастанию
    """
    n = len(arr)  # Получаем длину массива
    
    # Проходим по всем позициям от конца к началу
    for curr_size in range(n, 1, -1):
        # Находим индекс максимального элемента в неотсортированной части
        max_idx = arr.index(max(arr[:curr_size]))
        
        # Если максимальный элемент не на своём месте (не в конце текущей части)
        if max_idx != curr_size - 1:
            # Если максимальный элемент не в начале, переворачиваем его в начало
            if max_idx != 0:
                # Переворачиваем префикс до max_idx + 1
                arr[:max_idx + 1] = arr[:max_idx + 1][::-1]
                # print(f"Переворот до {max_idx + 1}: {arr}")  # Для отладки
            
            # Теперь максимальный элемент в начале — переворачиваем всю текущую часть
            arr[:curr_size] = arr[:curr_size][::-1]
            # print(f"Переворот всей части {curr_size}: {arr}")  # Для отладки
    
    return arr



# Пример использования
if __name__ == "__main__":
    # Исходный массив
    data = [3, 6, 1, 9, 4, 2]
    print(f"Исходный массив: {data}")
    
    # Сортируем
    sorted_data = pancake_sort(data)
    
    print(f"Отсортированный массив: {sorted_data}")


Результат работы алгоритма 

Исходный массив: [3, 6, 1, 9, 4, 2]
Отсортированный массив: [1, 2, 3, 4, 6, 9



3.Сортировка бусинами (гравитационная)

Код 

def bead_sort(arr):
    """
    Сортировка бусинами (гравитационная сортировка).
    
    Параметры:
        arr (list): список натуральных чисел для сортировки
    
    Возвращает:
        list: отсортированный по возрастанию список
    """
    # Проверяем, что массив не пуст
    if not arr:
        return arr
    
    # Проверяем, что все элементы — натуральные числа (≥ 0)
    if any(x < 0 for x in arr):
        raise ValueError("Все элементы должны быть натуральными числами (≥ 0)")
    
    # Находим максимальное число — оно определит высоту «решётки»
    max_val = max(arr)
    
    # Создаём двумерную «решётку» (матрицу) из бусин
    # Строки — уровни, столбцы — стержни
    # Изначально все ячейки заполнены нулями (нет бусин)
    beads = [[0] * max_val for _ in range(len(arr))]
    
    # «Размещаем» бусины на стержнях
    # Для каждого числа из входного массива:
    # - берём соответствующий стержень (столбец)
    # - ставим бусины на нижние `arr[i]` позиций
    for i, num in enumerate(arr):
        for j in range(num):
            beads[i][j] = 1  # 1 = есть бусина
    
    # «Гравитация»: бусины падают вниз
    # Для каждого уровня (строки) считаем количество бусин
    # и заполняем нижний ряд этим количеством бусин
    for j in range(max_val):  # для каждого столбца
        total_beads = sum(beads[i][j] for i in range(len(arr)))  # считаем бусины в столбце
        
        # Очищаем столбец
        for i in range(len(arr)):
            beads[i][j] = 0
        
        # Заполняем нижние `total_beads` позиций бусинами
        for i in range(total_beads):
            beads[len(arr) - 1 - i][j] = 1  # снизу вверх
    
    # Считываем результат: для каждого стержня считаем количество бусин
    sorted_arr = []
    for i in range(len(arr)):
        # Считаем бусины на стержне i
        bead_count = sum(beads[i][j] for j in range(max_val))
        sorted_arr.append(bead_count)
    
    return sorted_arr



# Пример использования
if __name__ == "__main__":
    # Тестовый массив
    test_array = [5, 3, 1, 7, 4, 1, 2]
    print("Исходный массив:", test_array)
    
    # Сортируем
    result = bead_sort(test_array)
    print("Отсортированный массив:", result)



Результат работы алгоритма 

Исходный массив: [5, 3, 1, 7, 4, 1, 2]
Отсортированный массив: [1, 1, 2, 3, 4, 5, 7]




4. Поиск скачками (Jump Search) 


Код

import math

def jump_search(arr, target):
    """
    Алгоритм поиска скачками (Jump Search) в отсортированном массиве.
    
    Параметры:
    arr (list): отсортированный список чисел
    target (int/float): искомое значение
    
    Возвращает:
    int: индекс элемента в массиве, если найден; -1, если не найден
    """
    n = len(arr)  # Получаем длину массива
    
    # Если массив пуст, элемент не найден
    if n == 0:
        return -1
    
    # Определяем размер «прыжка» — оптимальный равен корню из длины массива
    step = int(math.sqrt(n))
    
    # Начальный индекс для прыжков
    prev = 0
    
    # «Прыгаем» по массиву, пока не найдём участок, где может быть target
    # или пока не выйдем за границы массива
    while prev + step < n and arr[prev + step] < target:
        prev += step  # Переходим к следующему блоку
    
    # Теперь мы знаем, что target находится между prev и prev + step
    # Выполняем линейный поиск в этом диапазоне
    for i in range(prev, min(prev + step + 1, n)):
        if arr[i] == target:
            return i  # Возвращаем индекс найденного элемента
    
    # Если элемент не найден, возвращаем -1
    return -1


# Пример использования алгоритма
if __name__ == "__main__":
    # Отсортированный массив для поиска
    sorted_array = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25]
    target_value = 17
    
    # Вызываем функцию поиска
    result = jump_search(sorted_array, target_value)
    
    # Выводим результат
    if result != -1:
        print(f"Элемент {target_value} найден на позиции {result}")
    else:
        print(f"Элемент {target_value} не найден в массиве")




Результат работы алгоритма 

Элемент 17 найден на позиции 8



5. Экспоненциальный поиск (Exponential Search)


Код

def exponential_search(arr, target):
    """
    Экспоненциальный поиск элемента в отсортированном массиве.
    
    Параметры:
        arr (list): отсортированный список чисел
        target (int/float): искомое значение
    
    Возвращает:
        int: индекс элемента, если найден; -1, если не найден
    """
    n = len(arr)  # Длина массива
    
    # Базовый случай: массив пуст
    if n == 0:
        return -1
    
    # Если элемент находится на первой позиции
    if arr[0] == target:
        return 0
    
    # Находим границу диапазона, где может находиться target
    # Начинаем с индекса 1 и удваиваем его, пока не выйдем за границы
    # или пока arr[i] <= target
    i = 1
    while i < n and arr[i] <= target:
        i *= 2  # Удваиваем индекс: 1 → 2 → 4 → 8 → ...
    
    # Теперь искомый элемент точно находится в диапазоне [i//2, min(i, n-1)]
    # Применяем бинарный поиск в этом диапазоне
    left = i // 2      # Нижняя граница диапазона
    right = min(i, n - 1)  # Верхняя граница диапазона
    
    return binary_search(arr, target, left, right)



def binary_search(arr, target, left, right):
    """
    Бинарный поиск в заданном диапазоне массива.
    
    Параметры:
        arr (list): отсортированный список
        target (int/float): искомое значение
        left (int): левая граница диапазона
        right (int): правая граница диапазона
    
    Возвращает:
        int: индекс элемента, если найден; -1, если не найден
    """
    while left <= right:
        mid = (left + right) // 2  # Средний индекс
        
        if arr[mid] == target:
            return mid  # Элемент найден
        elif arr[mid] < target:
            left = mid + 1  # Ищем в правой




Результат работы алгоритма 

Элемент 13 найден на индексе 6





6. Тернарный поиск (Ternary Search)

Код

def ternary_search(arr, target):
    """
    Тернарный поиск элемента в отсортированном массиве.
    
    Параметры:
        arr (list): отсортированный список чисел
        target (int/float): искомое значение
    
    Возвращает:
        int: индекс элемента, если найден; -1, если не найден
    """
    left = 0                    # Левая граница поиска (начальный индекс)
    right = len(arr) - 1      # Правая граница поиска (конечный индекс)
    
    # Цикл продолжается, пока границы не пересекутся
    while left <= right:
        # Делим отрезок [left, right] на 3 части
        # Вычисляем две точки разделения
        mid1 = left + (right - left) // 3   # Первая точка деления (1/3 отрезка)
        mid2 = right - (right - left) // 3    # Вторая точка деления (2/3 отрезка)
        
        # Проверяем, совпадает ли искомое значение с элементами в точках деления
        if arr[mid1] == target:
            return mid1  # Нашли элемент, возвращаем его индекс
        
        if arr[mid2] == target:
            return mid2  # Нашли элемент, возвращаем его индекс
        
        # Определяем, в какой из трёх частей может быть target
        if target < arr[mid1]:
            # target лежит в левой трети: [left, mid1 - 1]
            right = mid1 - 1
        elif target > arr[mid2]:
            # target лежит в правой трети: [mid2 + 1, right]
            left = mid2 + 1
        else:
            # target лежит в средней трети: [mid1 + 1, mid2 - 1]
            left = mid1 + 1
            right = mid2 - 1
    
    # Элемент не найден
    return -1



# Пример использования
if __name__ == "__main__":
    # Отсортированный массив для поиска
    array = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
    target = 7
    
    result = ternary_search(array, target)
    
    if result != -1:
        print(f"Элемент {target} найден на позиции {result}")
    else:
        print(f"Элемент {target} не найден в массиве")


Результат работы алгоритма

Элемент 7 найден на позиции 3

