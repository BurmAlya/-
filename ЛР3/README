Бинарная куча (binary heap)
Суть структуры
Бинарная куча — это полное двоичное дерево, где:
все уровни (кроме, возможно, последнего) полностью заполнены;
узлы последнего уровня сдвинуты максимально влево;
соблюдается свойство кучи:
в max‑heap значение узла ≥ значений его потомков;
в min‑heap значение узла ≤ значений его потомков.
Ключевые характеристики
Доступ к экстремальному элементу (максимуму/минимуму) — O(1).
Вставка и удаление корня — O(log n).
Применение: приоритетные очереди, пирамидальная сортировка, алгоритм Дейкстры.
Реализация по языкам
Python
Используется модуль heapq для работы с min‑heap. Для max‑heap значения инвертируют.
Основные функции:
heappush(heap, item) — вставка;
heappop(heap) — удаление минимума;
heapify(heap) — преобразование списка в кучу за O(n).
Java
Реализуется через ArrayList и интерфейс Comparable/Comparator.
Альтернатива — класс PriorityQueue (по умолчанию min‑heap).
Ручные методы: insert(), extractMin()/extractMax(), heapifyUp()/heapifyDown().
C++
Используется std::vector и алгоритмы из ``:
std::push_heap() — добавление элемента;
std::pop_heap() — перемещение максимума в конец;
std::make_heap() — построение кучи за O(n).
Биномиальная куча
Суть структуры
Набор биномиальных деревьев разной степени (ранга), объединённых по правилам. Каждое дерево:
удовлетворяет свойству кучи (значение узла ≥ значения родителя);
позволяет эффективно сливать две кучи за O(log n).
Реализация по языкам
Python
Используются:
класс узла (ключ, ссылки на первого ребёнка, следующего брата, родителя);
класс кучи (список корней деревьев);
методы для слияния, вставки, извлечения минимума.
Java
Аналогично Python, но с строгой типизацией:
класс узла (поля для ключа, ссылок на ребёнка, брата, родителя);
класс кучи (список корней, например, LinkedList);
вспомогательные приватные методы для работы с деревьями.
C++
Применяются:
структура узла (ключ, указатели на ребёнка, брата, родителя);
класс кучи (вектор/список указателей на корни);
низкоуровневые операции с указателями.
Куча Фибоначчи
Суть структуры
Набор деревьев, упорядоченных по принципу min‑heap (корень поддерева — минимум среди потомков). Отличается высокой асимптотической эффективностью операций.
Реализация по языкам
Python
Объектно‑ориентированный подход:
класс Node (ключ, указатели на родителя, ребёнка, соседей, флаг отметки);
класс FibonacciHeap (указатель на минимум, счётчик узлов, методы операций);
динамическая типизация упрощает работу со сложными ссылками.
Java
Строгая типизация:
класс FibonacciHeapNode (ключ, родитель, ребёнок, соседи, степень, отметка);
класс FibonacciHeap (минимальный узел, размер, методы: вставка, извлечение минимума и др.);
параметризованные типы (<T>) для универсальности.
C++
Низкоуровневая реализация:
структура/класс Node (ключ, указатели на родительский, дочерний, левый/правый узлы, степень, флаг);
класс FibonacciHeap (указатель на минимум, счётчик узлов);
управление памятью через new/delete или интеллектуальные указатели (std::unique_ptr, std::shared_ptr).
Хэш‑таблица
Суть структуры
Эффективная структура для хранения пар «ключ‑значение» с быстрым доступом по ключу.
Реализация по языкам
Python
Встроенный тип dict:
использует открытую адресацию с мультипликативным хешированием;
автоматически масштабируется.
Java
Класс HashMap:
реализует метод цепочек (каждый индекс — связанный список или красно‑чёрное дерево при коллизиях);
поддерживает настраиваемый коэффициент загрузки и начальную ёмкость.
C++
Контейнер unordered_map из STL:
реализует хэш‑таблицу с цепочками или открытой адресацией (зависит от реализации STL).
