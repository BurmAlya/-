## Структуры данных на Java: реализация и описание
### 1. Бинарная куча (BinaryMinHeap)
**Суть структуры**  
Полная реализация минимальной бинарной кучи на массиве. Гарантирует:
- быстрый доступ к минимуму (`peek`);
- добавление элементов (`insert`);
- удаление минимума (`extractMin`).
**Ключевые методы**  
- `parent()`, `leftChild()`, `rightChild()` — вычисление индексов узлов;
- `swap()` — обмен элементов в массиве;
- `heapifyUp()` — восстановление свойства кучи после вставки;
- `heapifyDown()` — восстановление после извлечения.
**Особенности реализации**  
- Фиксированная ёмкость (`capacity`), задаваемая при создании;
- Проверка переполнения при вставке;
- Исключение `IllegalStateException` при операциях с пустой кучей.
**Пример использования**  
```java
BinaryMinHeap heap = new BinaryMinHeap(10);
heap.insert(10); heap.insert(5); heap.insert(20);
System.out.println("Min: " + heap.peek());        // 5
System.out.println("Extracted: " + heap.extractMin()); // 5
```
### 2. Биномиальная куча (BinomialHeap)
**Суть структуры**  
Коллекция биномиальных деревьев разной степени. Поддерживает:
- эффективное слияние (`merge`);
- добавление (`insert`);
- поиск и удаление минимума (`findMin`, `extractMin`).
**Основные компоненты**  
- `BinomialNode` — узел с полями: ключ, степень, родитель, первый ребёнок, следующий брат;
- `roots` — список корней биномиальных деревьев;
- `mergeTrees()` — объединение двух деревьев одинаковой степени;
- консолидация при слиянии (объединение деревьев одной степени).
**Алгоритм слияния**  
1. Объединение списков корней;
2. Последовательная проверка степеней;
3. Слияние деревьев одинаковой степени.
**Пример использования**  
```java
BinomialHeap heap = new BinomialHeap();
heap.insert(10); heap.insert(5); heap.insert(20);
System.out.println("Min: " + heap.extractMin());   // 5
System.out.println("New min: " + heap.findMin().key); // 10
```
### 3. Куча Фибоначчи (FibonacciHeap)
**Суть структуры**  
Высокоэффективная куча с амортизированными операциями:
- вставка и слияние за *O(1)*;
- извлечение минимума за *O(log n)*.
**Ключевые элементы**  
- `minNode` — указатель на узел с минимальным ключом;
- циклический корневой список (связи `left`/`right`);
- поля `parent`, `child`, `marked` для управления структурой;
- методы `cut()` и `cascadeCut()` для поддержания баланса.
**Важные операции**  
- `insert()` — добавление в корневой список;
- `extractMin()` — удаление корня, добавление его детей в корневой список, консолидация;
- `decreaseKey()` — уменьшение ключа с каскадным вырезанием при необходимости;
- `merge()` — объединение корневых списков.
**Консолидация**  
Использует массив для группировки деревьев по степеням, затем объединяет их.
**Пример использования**  
```java
FibonacciHeap heap = new FibonacciHeap();
heap.insert(10); heap.insert(5); heap.insert(3);
System.out.println("Min: " + heap.findMin());     // 3
System.out.println("Extracted: " + heap.extractMin()); // 3
```
### 4. Хэш‑таблица (HashTable)
**Суть структуры**  
Открытая адресация с линейным пробированием. Реализует:
- добавление (`put`);
- получение (`get`);
- проверку наличия (`containsKey`);
- удаление (`remove`).
**Основные параметры**  
- Начальная ёмкость: 16;
- Коэффициент заполнения: 0.75;
- Два массива: `keys` и `values`.
**Ключевые механизмы**  
- `hash()` — вычисление индекса по ключу;
- `findIndex()` — поиск позиции с учётом коллизий;
- `resize()` — удвоение ёмкости и перехеширование при заполнении > 75 %;
- линейное пробирование при коллизиях.
**Обработка удаления**  
При удалении происходит перехеширование последующих элементов для сохранения целостности цепочки.
**Пример использования**  
```java
HashTable<String, Integer> table = new HashTable<>();
table.put("apple", 10); table.put("banana", 20);
System.out.println(table.get("apple"));           // 10
System.out.println(table.containsKey("banana"));   // true
table.remove("banana");
System.out.println(table.size());               // 1
``
**Общие замечания**  
1. Все реализации используют обобщённые типы (`<K, V>`) для универсальности.
2. Обработка ошибок:  
   - `IllegalArgumentException` для недопустимых аргументов (например, `null`-ключ);
   - `IllegalStateException` для операций с пустыми/переполненными структурами.
3. Память:  
   - В `BinomialHeap` и `FibonacciHeap` — ручное управление узлами;
   - В `HashTable` — автоматическое через массивы.
4. Производительность:  
   - Бинарная куча: *O(log n)* для вставки/удаления;
   - Биномиальная куча: *O(log n)* для слияния;
   - Куча Фибоначчи: *O(1)* амортизированное для вставки/слияния;
   - Хэш‑таблица: *O(1)* среднее для основных операций.
