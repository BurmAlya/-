## Структуры данных: реализация на C++
### 1. Бинарная куча (MaxHeap)
**Описание**  
Полная реализация максимальной кучи на основе `std::vector`. Обеспечивает:
- добавление элемента (`insert`);
- извлечение максимума (`extractMax`);
- просмотр максимума без удаления (`getMax`);
- проверку пустоты и размера.
**Ключевые механизмы**  
- `siftUp` — проталкивание вверх после вставки;
- `siftDown` — проталкивание вниз после извлечения;
- внутренний контейнер `std::vector<int>` для хранения элементов.
**Пример использования**  
```cpp
MaxHeap heap;
heap.insert(10); heap.insert(20); heap.insert(5);
std::cout << "Максимум: " << heap.getMax() << std::endl;  // 20
std::cout << "Извлечён: " << heap.extractMax() << std::endl;  // 20
```
2. Биномиальная куча (BinomialHeap)
**Описание**  
Реализация биномиальной кучи через список корней биномиальных деревьев. Поддерживает:
- вставка (`insert`);
- объединение (`merge`);
- извлечение минимума (`extractMin`);
- уменьшение ключа (`decreaseKey`).
**Ключевые компоненты**  
- `BinomialNode` — узел с полями: ключ, степень, родитель, первый ребёнок, следующий брат;
- `mergeTrees` — слияние двух деревьев одинаковой степени;
- `consolidate` — консолидация кучи (объединение деревьев одной степени);
- список корней (`head`) для управления деревьями.
**Особенности**  
- Эффективное слияние за *O(log n)*;
- использование указателей для связи узлов;
- ручное управление памятью (удаление узлов в `clear`).
**Пример использования**  
```cpp
BinomialHeap<int> heap;
heap.insert(10); heap.insert(5); heap.insert(20);
std::cout << "Минимум: " << heap.extractMin() << std::endl;  // 5
```
### 3. Куча Фибоначчи (FibonacciHeap)
**Описание**  
Высокоэффективная структура с амортизированными операциями. Реализует:
- вставка (`insert`);
- извлечение минимума (`extractMin`);
- уменьшение ключа (`decreaseKey`);
- объединение (`merge`).
**Ключевые элементы**  
- `FibNode` — узел с полями: ключ, степень, отметка, родитель, первый ребёнок, левый/правый соседи;
- циклический корневой список (связан через `left`/`right`);
- `consolidate` — объединение деревьев одинаковой степени;
- `cascadingCut` — каскадное вырезание для поддержания баланса.
**Преимущества**  
- Вставка и объединение за *O(1)* (амортизированное);
- Извлечение минимума за *O(log n)* (амортизированное).
**Пример использования**  
```cpp
FibonacciHeap<int> heap;
auto n1 = heap.insert(10); auto n2 = heap.insert(5);
std::cout << "Минимум: " << heap.extractMin() << std::endl;  // 5
heap.decreaseKey(n1, 1);
std::cout << "Новый минимум: " << heap.extractMin() << std::endl;  // 1
```
### 4. Хэш‑таблица (HashTable)
**Описание**  
Реализация открытой адресации с цепочками на базе `std::vector` и `std::list`. Поддерживает:
- вставка (`insert`);
- поиск (`find`);
- удаление (`remove`);
- проверку наличия (`contains`).
**Основные механизмы**  
- `hash` — простая хеш‑функция через `std::hash`;
- `rehash` — увеличение ёмкости и перехеширование при заполнении > 70 %;
- цепочки коллизий хранятся в `std::list<std::pair<Key, Value>>`;
- автоматическое масштабирование.
**Параметры**  
- Начальная ёмкость: 8 (по умолчанию);
- Коэффициент заполнения: 0.7.
**Пример использования**  
```cpp
HashTable<std::string, int> ht;
ht.insert("apple", 10); ht.insert("banana", 20);
int value;
if (ht.find("apple", value)) {
    std::cout << "apple: " << value << std::endl;  // 10
}
ht.remove("banana");
std::cout << "Размер: " << ht.getSize() << std::endl;  // 1
```
**Общие замечания**  
1. Все реализации используют шаблоны (`template`) для универсальности типов.
2. Управление памятью:  
   - В `BinomialHeap` и `FibonacciHeap` — ручное удаление узлов;
   - В `HashTable` — автоматическое управление через STL‑контейнеры.
3. Ошибки обрабатываются через исключения (`std::runtime_error`, `std::invalid_argument`).
